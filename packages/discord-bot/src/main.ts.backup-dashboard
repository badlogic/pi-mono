#!/usr/bin/env node
/**
 * Pi Discord Bot - A full agentic Discord bot powered by AI
 * Similar to pi-mom but for Discord - with bash, read, write, edit tools
 * Supports both slash commands and @mentions
 */

import { Agent, ProviderTransport, type AgentEvent } from "@mariozechner/pi-agent-core";
import { type AgentTool, type Model } from "@mariozechner/pi-ai";
import { Type } from "@sinclair/typebox";
import {
	Client,
	GatewayIntentBits,
	Message,
	Partials,
	TextChannel,
	REST,
	Routes,
	SlashCommandBuilder,
	ChatInputCommandInteraction,
	InteractionResponse,
	EmbedBuilder,
	ButtonBuilder,
	ButtonStyle,
	ActionRowBuilder,
	ComponentType,
} from "discord.js";
import chalk from "chalk";
import { spawn } from "child_process";
import { existsSync, mkdirSync, appendFileSync, readFileSync, writeFileSync, unlinkSync } from "fs";
import { join, resolve } from "path";
import "dotenv/config";
import cron from "node-cron";
import express from "express";
import { Analytics } from "./analytics.js";
import { getAllMcpTools, createGithubRepoSearchTool, createHfModelSearchTool, createHfDatasetSearchTool, createMemoryRecallTool, createMemoryStoreTool, createWebScrapeTool, createGithubListIssuesTool, createTaskListTool, createTaskCreateTool, createCodebaseKnowledgeTool, createFreeWebSearchTool, createSkillListTool, createSkillLoadTool, createMemoryUpdateTool, createSkillCreateTool, withRetry } from "./mcp-tools.js";
import { initDatabase, type BotDatabase } from "./database.js";
import { TaskScheduler } from "./scheduler.js";

// ============================================================================
// Configuration
// ============================================================================

const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;

// Security: Restrict to specific user IDs (empty = allow all)
const ALLOWED_USER_IDS = (process.env.ALLOWED_USER_IDS || "").split(",").filter(Boolean);

// Admin/Owner user ID
const OWNER_USER_ID = "1284556970082435072";

function isUserAllowed(userId: string): boolean {
	if (ALLOWED_USER_IDS.length === 0) return true; // No restriction if not configured
	return ALLOWED_USER_IDS.includes(userId);
}

function isOwner(userId: string): boolean {
	return userId === OWNER_USER_ID;
}

// ============================================================================
// Model Configuration & Management
// ============================================================================

const DEFAULT_MODEL_ID = "devstral-small-2";
const OLLAMA_BASE_URL = "http://localhost:11434";

// OpenRouter Configuration
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || "";
const OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1";

// Provider types
type ProviderType = "ollama" | "openrouter";
let currentProvider: ProviderType = OPENROUTER_API_KEY ? "openrouter" : "ollama"; // Default to OpenRouter if key available

// OpenRouter model presets (benchmarked for agentic tasks)
const OPENROUTER_MODELS: Record<string, { id: string; name: string; cost: string }> = {
	// PREMIUM MODELS (Best quality)
	"claude-sonnet": {
		id: "anthropic/claude-sonnet-4",
		name: "Claude Sonnet 4 (Best Overall)",
		cost: "$3/$15 per M - Top tier reasoning"
	},
	"gpt-4o": {
		id: "openai/gpt-4o",
		name: "GPT-4o (OpenAI Best)",
		cost: "$2.50/$10 per M - Multimodal"
	},
	"gemini-pro": {
		id: "google/gemini-2.5-pro-preview",
		name: "Gemini 2.5 Pro (Google Best)",
		cost: "$1.25/$10 per M - Long context"
	},
	// AGENTIC MODELS (tool calling, fast)
	"mistral-small": {
		id: "mistralai/mistral-small-3.1-24b-instruct",
		name: "Mistral Small 3.1 24B (Best Agentic)",
		cost: "$0.03/$0.11 per M - Fast tool calling"
	},
	"deepseek-v3": {
		id: "deepseek/deepseek-chat-v3.1",
		name: "DeepSeek V3.1 (Best Reasoning)",
		cost: "$0.15/$0.75 per M - Smart but slower"
	},
	"qwen-72b": {
		id: "qwen/qwen-2.5-72b-instruct",
		name: "Qwen 2.5 72B (Balanced)",
		cost: "$0.07/$0.26 per M - Good all-around"
	},
	// FAST/CHEAP MODELS
	"gemini-flash": {
		id: "google/gemini-2.5-flash-preview",
		name: "Gemini 2.5 Flash (Fast+Cheap)",
		cost: "$0.15/$0.60 per M - Great value"
	},
	"gpt-4o-mini": {
		id: "openai/gpt-4o-mini",
		name: "GPT-4o Mini (OpenAI Fast)",
		cost: "$0.15/$0.60 per M - Quick tasks"
	},
	"claude-haiku": {
		id: "anthropic/claude-3.5-haiku",
		name: "Claude 3.5 Haiku (Anthropic Fast)",
		cost: "$0.80/$4 per M - Speed demon"
	},
	"llama-3.3-70b": {
		id: "meta-llama/llama-3.3-70b-instruct",
		name: "Llama 3.3 70B (Open Source Best)",
		cost: "$0.12/$0.30 per M - High quality"
	},
	"llama-3.1-8b": {
		id: "meta-llama/llama-3.1-8b-instruct",
		name: "Llama 3.1 8B (Cheapest)",
		cost: "$0.02/$0.03 per M - Simple tasks"
	},
};
const DEFAULT_OPENROUTER_MODEL = "mistral-small"; // Fast + cheap + good agentic

// Model registry - stores available models from Ollama
interface OllamaModel {
	name: string;
	size: number;
	modified_at: string;
	details?: {
		parameter_size?: string;
		quantization_level?: string;
		family?: string;
	};
}

// Create model config from Ollama model name
function createOllamaModelConfig(modelId: string): Model<"openai-completions"> {
	return {
		id: modelId,
		name: modelId,
		api: "openai-completions",
		provider: "ollama",
		baseUrl: `${OLLAMA_BASE_URL}/v1`,
		reasoning: false,
		input: ["text"],
		cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 },
		contextWindow: 32000, // Conservative default, varies by model
		maxTokens: 8192,
	};
}

// Create model config for OpenRouter
function createOpenRouterModelConfig(modelKey: string): Model<"openai-completions"> {
	const preset = OPENROUTER_MODELS[modelKey] || OPENROUTER_MODELS[DEFAULT_OPENROUTER_MODEL];
	return {
		id: preset.id,
		name: preset.name,
		api: "openai-completions",
		provider: "openrouter",
		baseUrl: OPENROUTER_BASE_URL,
		reasoning: false,
		input: ["text"],
		cost: { input: 0.00002, output: 0.00003, cacheRead: 0, cacheWrite: 0 },
		contextWindow: 131072,
		maxTokens: 8192,
		headers: {
			"Authorization": `Bearer ${OPENROUTER_API_KEY}`,
			"HTTP-Referer": "https://discord.com/pi-agent",
			"X-Title": "Pi Discord Agent"
		},
	};
}

// Get model config based on current provider
function createModelConfig(modelId: string): Model<"openai-completions"> {
	if (currentProvider === "openrouter") {
		return createOpenRouterModelConfig(modelId);
	}
	return createOllamaModelConfig(modelId);
}

// Global model state (per-user preferences)
const userModels = new Map<string, string>(); // userId -> modelId
let globalModelId = OPENROUTER_API_KEY ? DEFAULT_OPENROUTER_MODEL : DEFAULT_MODEL_ID;

function getUserModel(userId: string): Model<"openai-completions"> {
	const modelId = userModels.get(userId) || globalModelId;
	return createModelConfig(modelId);
}

function setUserModel(userId: string, modelId: string): void {
	userModels.set(userId, modelId);
	logInfo(`User ${userId} switched to model: ${modelId}`);
}

function setGlobalModel(modelId: string): void {
	globalModelId = modelId;
	logInfo(`Global model switched to: ${modelId}`);
}

function getCurrentModelId(userId?: string): string {
	if (userId && userModels.has(userId)) {
		return userModels.get(userId)!;
	}
	return globalModelId;
}

// Fetch available models from Ollama API
async function fetchOllamaModels(): Promise<OllamaModel[]> {
	try {
		const response = await fetch(`${OLLAMA_BASE_URL}/api/tags`);
		if (!response.ok) {
			throw new Error(`Ollama API error: ${response.status}`);
		}
		const data = await response.json() as { models: OllamaModel[] };
		return data.models || [];
	} catch (error) {
		logError("Failed to fetch Ollama models", error instanceof Error ? error.message : String(error));
		return [];
	}
}

// Format model size for display
function formatModelSize(bytes: number): string {
	if (bytes < 1024 * 1024 * 1024) {
		return `${(bytes / (1024 * 1024)).toFixed(0)}MB`;
	}
	return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)}GB`;
}

// Default model for initialization
const model: Model<"openai-completions"> = createModelConfig(DEFAULT_MODEL_ID);

// Truncation limits
const DEFAULT_MAX_LINES = 2000;
const DEFAULT_MAX_BYTES = 50 * 1024; // 50KB

// ============================================================================
// Bot Statistics Tracking
// ============================================================================

interface BotStats {
	startTime: number;
	commandsProcessed: number;
	messagesProcessed: number;
	errorsCount: number;
	userInteractions: Map<string, { username: string; count: number; lastSeen: number }>;
}

const botStats: BotStats = {
	startTime: Date.now(),
	commandsProcessed: 0,
	messagesProcessed: 0,
	errorsCount: 0,
	userInteractions: new Map(),
};

// ============================================================================
// Rate Limiting
// ============================================================================

interface RateLimitEntry {
	count: number;
	resetAt: number;
}

class RateLimiter {
	private limits = new Map<string, RateLimitEntry>();
	private readonly maxRequests: number;
	private readonly windowMs: number;

	constructor(maxRequests = 10, windowMs = 60000) {
		this.maxRequests = maxRequests;
		this.windowMs = windowMs;

		// Clean up expired entries every minute
		setInterval(() => this.cleanup(), 60000);
	}

	isRateLimited(key: string): boolean {
		const now = Date.now();
		const entry = this.limits.get(key);

		if (!entry || now > entry.resetAt) {
			this.limits.set(key, { count: 1, resetAt: now + this.windowMs });
			return false;
		}

		if (entry.count >= this.maxRequests) {
			return true;
		}

		entry.count++;
		return false;
	}

	getRemainingRequests(key: string): number {
		const entry = this.limits.get(key);
		if (!entry || Date.now() > entry.resetAt) {
			return this.maxRequests;
		}
		return Math.max(0, this.maxRequests - entry.count);
	}

	getResetTime(key: string): number {
		const entry = this.limits.get(key);
		if (!entry) return 0;
		return Math.max(0, entry.resetAt - Date.now());
	}

	private cleanup(): void {
		const now = Date.now();
		for (const [key, entry] of this.limits) {
			if (now > entry.resetAt) {
				this.limits.delete(key);
			}
		}
	}
}

// Rate limiters for different scopes
const userRateLimiter = new RateLimiter(20, 60000);  // 20 requests per minute per user
const globalRateLimiter = new RateLimiter(100, 60000); // 100 requests per minute global
const webhookRateLimiter = new RateLimiter(30, 60000); // 30 webhook requests per minute

// ============================================================================
// Input Sanitization
// ============================================================================

function sanitizeInput(input: string): string {
	// Remove null bytes
	let sanitized = input.replace(/\0/g, "");

	// Limit length
	if (sanitized.length > 10000) {
		sanitized = sanitized.substring(0, 10000);
	}

	return sanitized;
}

function isValidChannelId(id: string): boolean {
	return /^\d{17,20}$/.test(id);
}

// ============================================================================
// Tool Usage Tracking
// ============================================================================

interface ToolUsageStats {
	name: string;
	count: number;
	totalDuration: number;
	errors: number;
	lastUsed: number;
}

const toolUsageStats = new Map<string, ToolUsageStats>();

function trackToolUsage(toolName: string, duration: number, success: boolean): void {
	const existing = toolUsageStats.get(toolName);
	if (existing) {
		existing.count++;
		existing.totalDuration += duration;
		if (!success) existing.errors++;
		existing.lastUsed = Date.now();
	} else {
		toolUsageStats.set(toolName, {
			name: toolName,
			count: 1,
			totalDuration: duration,
			errors: success ? 0 : 1,
			lastUsed: Date.now(),
		});
	}
}

function getToolUsageStats(): ToolUsageStats[] {
	return Array.from(toolUsageStats.values())
		.sort((a, b) => b.count - a.count);
}

function trackUserInteraction(userId: string, username: string): void {
	const existing = botStats.userInteractions.get(userId);
	if (existing) {
		existing.count++;
		existing.lastSeen = Date.now();
	} else {
		botStats.userInteractions.set(userId, { username, count: 1, lastSeen: Date.now() });
	}
}

// Analytics instance (initialized in main)
let analytics: Analytics;

// Database and Scheduler instances (initialized in main)
let db: BotDatabase;
let taskScheduler: TaskScheduler;

// ============================================================================
// Admin Action Logging
// ============================================================================

function logAdminAction(userId: string, username: string, action: string, details?: string): void {
	const timestamp = new Date().toISOString();
	const logEntry = `[${timestamp}] [ADMIN] ${username} (${userId}): ${action}${details ? ` - ${details}` : ""}\n`;

	try {
		const logPath = "/opt/discord-bot-data/admin-actions.log";
		appendFileSync(logPath, logEntry);
	} catch (error) {
		logError("Failed to write admin log", error instanceof Error ? error.message : String(error));
	}

	logInfo(`[ADMIN] ${username}: ${action}${details ? ` - ${details}` : ""}`);
}

// ============================================================================
// Runtime Configuration
// ============================================================================

interface RuntimeConfig {
	[key: string]: string | number | boolean;
}

const runtimeConfig: RuntimeConfig = {
	debugMode: false,
	maxResponseLength: 2000,
	defaultTimeout: 120,
};

// ============================================================================
// Security: Rate Limiting
// ============================================================================

const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute window
const RATE_LIMIT_MAX_REQUESTS = 20; // Max requests per window per user (updated)

// Use the new RateLimiter class defined above
function checkRateLimit(userId: string): { allowed: boolean; remaining: number; resetIn: number } {
	const isLimited = userRateLimiter.isRateLimited(userId);
	return {
		allowed: !isLimited,
		remaining: userRateLimiter.getRemainingRequests(userId),
		resetIn: userRateLimiter.getResetTime(userId),
	};
}

// ============================================================================
// Security: Dangerous Command Detection & Approval
// ============================================================================

const DANGEROUS_PATTERNS = [
	/\bsudo\s+/i,
	/\brm\s+.*-[rRf]/i,           // rm with dangerous flags
	/\brm\s+-[rRf]/i,
	/\brm\s+\/[^\s]*/i,           // rm anything starting with /
	/\bdd\s+/i,
	/>\s*\/dev\/(sda|nvme|vd)/i,
	/\bmkfs/i,
	/\bshutdown/i,
	/\breboot/i,
	/\bkill\s+-9/i,
	/\bpkill\s+-9/i,
	/\bchmod\s+777/i,
	/\bchown\s+.*:/i,
	/\bcurl\s+.*\|\s*(ba)?sh/i,   // curl | bash
	/\bwget\s+.*\|\s*(ba)?sh/i,   // wget | bash
	/\b:()\s*{\s*:\|:\s*&\s*}/i,  // fork bomb
	/\bformat\s+/i,
	/\bfdisk\s+/i,
	/\bparted\s+/i,
];

function isDangerousCommand(command: string): boolean {
	return DANGEROUS_PATTERNS.some(pattern => pattern.test(command));
}

// Global context for approval requests (set per-request)
let currentApprovalContext: {
	message: Message | null;
	userId: string;
} | null = null;

function setApprovalContext(message: Message | null, userId: string): void {
	currentApprovalContext = { message, userId };
}

async function requestApproval(command: string): Promise<boolean> {
	if (!currentApprovalContext?.message) {
		logWarning("No approval context available, denying dangerous command");
		return false;
	}

	const { message, userId } = currentApprovalContext;
	const channel = message.channel;

	// Check if channel supports sending messages
	if (!("send" in channel) || typeof channel.send !== "function") {
		logWarning("Channel does not support sending messages");
		return false;
	}

	try {
		const approvalMsg = await (channel as TextChannel).send(
			`**Dangerous command detected:**\n\`\`\`bash\n${command.substring(0, 500)}\n\`\`\`\nReact ‚úÖ to approve, ‚ùå to deny (60s timeout)`
		);

		await approvalMsg.react("‚úÖ");
		await approvalMsg.react("‚ùå");

		const collected = await approvalMsg.awaitReactions({
			filter: (reaction: { emoji: { name: string | null } }, user: { id: string }) =>
				["‚úÖ", "‚ùå"].includes(reaction.emoji.name || "") &&
				user.id === userId,
			max: 1,
			time: 60000,
		});

		const reaction = collected.first();
		if (reaction?.emoji.name === "‚úÖ") {
			await approvalMsg.edit("‚úÖ Command approved.");
			logInfo(`Dangerous command approved by user: ${command.substring(0, 50)}...`);
			return true;
		} else if (reaction?.emoji.name === "‚ùå") {
			await approvalMsg.edit("‚ùå Command denied by user.");
			logWarning(`Dangerous command denied by user: ${command.substring(0, 50)}...`);
			return false;
		} else {
			await approvalMsg.edit("‚è∞ Approval timed out - command denied.");
			logWarning(`Dangerous command timed out: ${command.substring(0, 50)}...`);
			return false;
		}
	} catch (error) {
		logError("Approval request failed", error instanceof Error ? error.message : String(error));
		return false;
	}
}

// ============================================================================
// Slash Commands Definition
// ============================================================================

const slashCommands = [
	new SlashCommandBuilder()
		.setName("ask")
		.setDescription("Ask the AI assistant anything")
		.addStringOption((option) =>
			option.setName("question").setDescription("Your question or request").setRequired(true)
		),

	new SlashCommandBuilder()
		.setName("bash")
		.setDescription("Execute a bash command directly")
		.addStringOption((option) =>
			option.setName("command").setDescription("The bash command to execute").setRequired(true)
		)
		.addIntegerOption((option) =>
			option.setName("timeout").setDescription("Timeout in seconds (default: no limit)").setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("read")
		.setDescription("Read a file from the system")
		.addStringOption((option) =>
			option.setName("path").setDescription("Path to the file").setRequired(true)
		)
		.addIntegerOption((option) =>
			option.setName("lines").setDescription("Number of lines to read").setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("remember")
		.setDescription("Save something to memory")
		.addStringOption((option) =>
			option.setName("text").setDescription("What to remember").setRequired(true)
		)
		.addBooleanOption((option) =>
			option.setName("global").setDescription("Save to global memory (default: channel)").setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("memory")
		.setDescription("Show what the bot remembers"),

	new SlashCommandBuilder()
		.setName("forget")
		.setDescription("Clear memory")
		.addBooleanOption((option) =>
			option.setName("global").setDescription("Clear global memory (default: channel)").setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("status")
		.setDescription("Show bot status and system info"),

	new SlashCommandBuilder()
		.setName("skills")
		.setDescription("List loaded skills and capabilities"),

	new SlashCommandBuilder()
		.setName("price")
		.setDescription("Get cryptocurrency price")
		.addStringOption((option) =>
			option.setName("symbol").setDescription("Crypto symbol (e.g., bitcoin, ethereum)").setRequired(true)
		),

	new SlashCommandBuilder()
		.setName("alert")
		.setDescription("Set a price alert")
		.addStringOption((option) =>
			option.setName("condition").setDescription("Alert condition (e.g., 'BTC > 50000')").setRequired(true)
		),

	new SlashCommandBuilder()
		.setName("news")
		.setDescription("Get latest crypto news headlines")
		.addStringOption((option) =>
			option.setName("topic").setDescription("News topic (optional)").setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("chart")
		.setDescription("Get TradingView chart link")
		.addStringOption((option) =>
			option.setName("symbol").setDescription("Trading symbol (e.g., BTCUSD)").setRequired(true)
		)
		.addStringOption((option) =>
			option.setName("timeframe").setDescription("Timeframe (1h, 4h, 1D, 1W)").setRequired(true)
		),

	new SlashCommandBuilder()
		.setName("convert")
		.setDescription("Currency converter")
		.addNumberOption((option) =>
			option.setName("amount").setDescription("Amount to convert").setRequired(true)
		)
		.addStringOption((option) =>
			option.setName("from").setDescription("From currency (e.g., usd, btc)").setRequired(true)
		)
		.addStringOption((option) =>
			option.setName("to").setDescription("To currency (e.g., eur, eth)").setRequired(true)
		),

	new SlashCommandBuilder()
		.setName("model")
		.setDescription("Manage AI model selection")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("list")
				.setDescription("Show available Ollama models")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("switch")
				.setDescription("Switch to a different model")
				.addStringOption((option) =>
					option.setName("name").setDescription("Model name (e.g., llama3, mistral)").setRequired(true)
				)
				.addBooleanOption((option) =>
					option.setName("global").setDescription("Set as global default (admin only)").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("info")
				.setDescription("Show current model information")
		),

	new SlashCommandBuilder()
		.setName("analytics")
		.setDescription("View bot usage analytics and statistics")
		.addStringOption((option) =>
			option
				.setName("period")
				.setDescription("Time period to view")
				.addChoices(
					{ name: "Today", value: "today" },
					{ name: "This Week", value: "week" },
					{ name: "All Time", value: "all" }
				)
				.setRequired(false)
		),

	new SlashCommandBuilder()
		.setName("provider")
		.setDescription("Switch AI provider (Ollama local or OpenRouter cloud)")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("status")
				.setDescription("Show current provider and available options")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("ollama")
				.setDescription("Switch to local Ollama (free, private)")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("openrouter")
				.setDescription("Switch to OpenRouter cloud (cheap, smart)")
				.addStringOption((option) =>
					option
						.setName("model")
						.setDescription("OpenRouter model")
						.addChoices(
							{ name: "Mistral Small 3.1 (Best Agentic) - $0.03/M", value: "mistral-small" },
							{ name: "DeepSeek V3.1 (Best Reasoning) - $0.15/M", value: "deepseek-v3" },
							{ name: "Qwen 2.5 72B (Balanced) - $0.07/M", value: "qwen-72b" },
							{ name: "Llama 3.1 8B (Cheapest) - $0.02/M", value: "llama-3.1-8b" }
						)
						.setRequired(false)
				)
		),

	// Admin Commands
	new SlashCommandBuilder()
		.setName("admin")
		.setDescription("Admin-only commands (owner access required)")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("stats")
				.setDescription("Show bot statistics (uptime, commands, memory)")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("users")
				.setDescription("List users who have used the bot")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("broadcast")
				.setDescription("Send message to all channels bot is in")
				.addStringOption((option) =>
					option.setName("message").setDescription("Message to broadcast").setRequired(true)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("reload")
				.setDescription("Reload skills from disk without restart")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("config")
				.setDescription("View or set runtime configuration")
				.addStringOption((option) =>
					option.setName("key").setDescription("Configuration key").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("value").setDescription("Configuration value (omit to view)").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("logs")
				.setDescription("Show recent bot logs")
				.addIntegerOption((option) =>
					option.setName("lines").setDescription("Number of lines to show (default: 50)").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("restart")
				.setDescription("Gracefully restart the bot (via systemd)")
		),

	new SlashCommandBuilder()
		.setName("tools")
		.setDescription("List all available MCP tools and capabilities")
		.addStringOption((option) =>
			option
				.setName("category")
				.setDescription("Filter by category")
				.addChoices(
					{ name: "All Tools", value: "all" },
					{ name: "Web & Search", value: "web" },
					{ name: "GitHub", value: "github" },
					{ name: "HuggingFace", value: "hf" },
					{ name: "Memory", value: "memory" },
					{ name: "Tasks", value: "tasks" },
					{ name: "Codebase Knowledge", value: "codebase" },
					{ name: "Skills System", value: "skills" },
					{ name: "Self-Management", value: "self" }
				)
				.setRequired(false)
		),

	// Creative generation commands
	new SlashCommandBuilder()
		.setName("generate")
		.setDescription("Generate creative content (images, music, video, voice)")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("image")
				.setDescription("Generate an image with FLUX")
				.addStringOption((option) =>
					option.setName("prompt").setDescription("Image description").setRequired(true)
				)
				.addStringOption((option) =>
					option
						.setName("model")
						.setDescription("FLUX model to use")
						.addChoices(
							{ name: "FLUX Dev (Best)", value: "flux-dev" },
							{ name: "FLUX Schnell (Fast)", value: "flux-schnell" },
							{ name: "FLUX Pro", value: "flux-pro" },
							{ name: "FLUX Realism", value: "flux-realism" },
							{ name: "Ideogram V2", value: "ideogram" },
							{ name: "Recraft V3", value: "recraft" }
						)
						.setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("music")
				.setDescription("Generate music with Suno AI")
				.addStringOption((option) =>
					option.setName("prompt").setDescription("Music description or lyrics").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("style").setDescription("Music style (e.g., 'hip hop', 'electronic')").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("video")
				.setDescription("Generate video from text or image")
				.addStringOption((option) =>
					option.setName("prompt").setDescription("Video description").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("image_url").setDescription("Optional: Image to animate").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("voice")
				.setDescription("Generate speech with VibeVoice or ElevenLabs")
				.addStringOption((option) =>
					option.setName("text").setDescription("Text to speak").setRequired(true)
				)
				.addStringOption((option) =>
					option
						.setName("engine")
						.setDescription("TTS engine")
						.addChoices(
							{ name: "VibeVoice (Multi-speaker)", value: "vibevoice" },
							{ name: "ElevenLabs (High quality)", value: "elevenlabs" },
							{ name: "OpenAI TTS", value: "openai" }
						)
						.setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("3d")
				.setDescription("Generate 3D model from image or text")
				.addStringOption((option) =>
					option.setName("prompt").setDescription("3D model description").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("image_url").setDescription("Optional: Image to convert to 3D").setRequired(false)
				)
		),

	// LiveKit voice commands
	new SlashCommandBuilder()
		.setName("livekit")
		.setDescription("Real-time voice/video with LiveKit")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("create")
				.setDescription("Create a voice room")
				.addStringOption((option) =>
					option.setName("name").setDescription("Room name").setRequired(true)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("join")
				.setDescription("Get token to join a room")
				.addStringOption((option) =>
					option.setName("room").setDescription("Room name").setRequired(true)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("list")
				.setDescription("List active rooms")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("record")
				.setDescription("Start/stop recording a room")
				.addStringOption((option) =>
					option.setName("room").setDescription("Room name").setRequired(true)
				)
				.addStringOption((option) =>
					option
						.setName("action")
						.setDescription("Action")
						.addChoices(
							{ name: "Start Recording", value: "start" },
							{ name: "Stop Recording", value: "stop" }
						)
						.setRequired(true)
				)
		),

	// Schedule command - manage scheduled tasks
	new SlashCommandBuilder()
		.setName("schedule")
		.setDescription("Manage scheduled tasks")
		.addSubcommand((subcommand) =>
			subcommand
				.setName("add")
				.setDescription("Add a new scheduled task")
				.addStringOption((option) =>
					option.setName("name").setDescription("Task name").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("cron").setDescription("Cron expression (e.g., '0 9 * * *' for 9 AM daily)").setRequired(true)
				)
				.addStringOption((option) =>
					option.setName("action").setDescription("Action to perform").setRequired(true)
				)
				.addChannelOption((option) =>
					option.setName("channel").setDescription("Channel to send results to (default: current)").setRequired(false)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("list")
				.setDescription("List all your scheduled tasks")
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("remove")
				.setDescription("Remove a scheduled task")
				.addStringOption((option) =>
					option.setName("id").setDescription("Task ID to remove").setRequired(true)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("toggle")
				.setDescription("Enable or disable a scheduled task")
				.addStringOption((option) =>
					option.setName("id").setDescription("Task ID to toggle").setRequired(true)
				)
		)
		.addSubcommand((subcommand) =>
			subcommand
				.setName("info")
				.setDescription("Get details about a scheduled task")
				.addStringOption((option) =>
					option.setName("id").setDescription("Task ID").setRequired(true)
				)
		),

	// Health check command
	new SlashCommandBuilder()
		.setName("health")
		.setDescription("Check bot health and API status"),

	// Reset command - clears conversation history
	new SlashCommandBuilder()
		.setName("reset")
		.setDescription("Clear conversation history for this channel"),

	// Backup command - creates data dump
	new SlashCommandBuilder()
		.setName("backup")
		.setDescription("Create a backup of bot data")
		.addStringOption((option) =>
			option
				.setName("scope")
				.setDescription("What to backup")
				.addChoices(
					{ name: "Channel Only", value: "channel" },
					{ name: "All Data", value: "all" }
				)
				.setRequired(false)
		),

	// Cost tracking command
	new SlashCommandBuilder()
		.setName("cost")
		.setDescription("View API usage costs")
		.addStringOption((option) =>
			option
				.setName("view")
				.setDescription("What to view")
				.addChoices(
					{ name: "My Usage", value: "me" },
					{ name: "Top Users", value: "top" },
					{ name: "Daily Breakdown", value: "daily" }
				)
				.setRequired(false)
		),
];

// ============================================================================
// CLI Parsing
// ============================================================================

function parseArgs(): { workingDir: string } {
	const args = process.argv.slice(2);
	let workingDir: string | undefined;

	for (const arg of args) {
		if (!arg.startsWith("-")) {
			workingDir = arg;
		}
	}

	if (!workingDir) {
		console.error("Usage: pi-discord <working-directory>");
		process.exit(1);
	}

	return { workingDir: resolve(workingDir) };
}

// ============================================================================
// Logging
// ============================================================================

function logInfo(message: string): void {
	console.log(chalk.blue("[INFO]"), message);
}

function logWarning(message: string, detail?: string): void {
	console.log(chalk.yellow("[WARN]"), message, detail ? chalk.dim(detail) : "");
}

function logError(message: string, detail?: string): void {
	console.error(chalk.red("[ERROR]"), message, detail ? chalk.dim(detail) : "");
}

function logTool(toolName: string, label: string): void {
	console.log(chalk.cyan("[TOOL]"), `${toolName}: ${label}`);
}

function logSlash(command: string, user: string): void {
	console.log(chalk.magenta("[SLASH]"), `/${command} by ${user}`);
}

// ============================================================================
// Discord UI Helpers (Embeds, Buttons)
// ============================================================================

function createResponseEmbed(title: string, description: string, color: number = 0x0099FF): EmbedBuilder {
	return new EmbedBuilder()
		.setColor(color)
		.setTitle(title)
		.setDescription(description.substring(0, 4096))
		.setTimestamp()
		.setFooter({ text: "Pi Discord Bot" });
}

function createStatusEmbed(currentModel: string, globalModel: string, uptime: string, workspace: string, channels: number): EmbedBuilder {
	const modelInfo = currentModel === globalModel
		? `\`${currentModel}\` (global)`
		: `\`${currentModel}\` (personal)`;

	return new EmbedBuilder()
		.setColor(0x00FF00)
		.setTitle("ü§ñ Pi Discord Bot Status")
		.addFields(
			{ name: "Current Model", value: modelInfo, inline: true },
			{ name: "Uptime", value: uptime, inline: true },
			{ name: "Active Channels", value: String(channels), inline: true },
			{ name: "Workspace", value: `\`${workspace}\``, inline: false },
		)
		.addFields(
			{ name: "AI Commands", value:
				"`/ask` - Ask the AI anything\n" +
				"`/model` - Manage AI models\n" +
				"`/remember` - Save to memory\n" +
				"`/memory` - Show memory\n" +
				"`/forget` - Clear memory",
				inline: true
			},
			{ name: "System Commands", value:
				"`/bash` - Run shell commands\n" +
				"`/read` - Read files\n" +
				"`/status` - Bot status\n" +
				"`/skills` - List capabilities",
				inline: true
			},
			{ name: "Crypto Commands", value:
				"`/price` - Get crypto price\n" +
				"`/alert` - Set price alert\n" +
				"`/news` - Latest news\n" +
				"`/chart` - TradingView chart\n" +
				"`/convert` - Currency converter",
				inline: true
			},
		)
		.setTimestamp()
		.setFooter({ text: "Or just @mention me!" });
}

function createFeedbackButtons(): ActionRowBuilder<ButtonBuilder> {
	return new ActionRowBuilder<ButtonBuilder>()
		.addComponents(
			new ButtonBuilder()
				.setCustomId("feedback_helpful")
				.setLabel("üëç Helpful")
				.setStyle(ButtonStyle.Success),
			new ButtonBuilder()
				.setCustomId("feedback_not_helpful")
				.setLabel("üëé Not Helpful")
				.setStyle(ButtonStyle.Danger),
			new ButtonBuilder()
				.setCustomId("feedback_more")
				.setLabel("üìù Tell me more")
				.setStyle(ButtonStyle.Primary),
		);
}

// ============================================================================
// Shell Utilities
// ============================================================================

function shellEscape(s: string): string {
	return `'${s.replace(/'/g, "'\\''")}'`;
}

interface ExecResult {
	stdout: string;
	stderr: string;
	code: number;
}

interface ExecOptions {
	timeout?: number;
	signal?: AbortSignal;
}

async function execCommand(command: string, options?: ExecOptions): Promise<ExecResult> {
	return new Promise((resolve, reject) => {
		const child = spawn("sh", ["-c", command], {
			detached: true,
			stdio: ["ignore", "pipe", "pipe"],
		});

		let stdout = "";
		let stderr = "";
		let timedOut = false;

		const timeoutHandle =
			options?.timeout && options.timeout > 0
				? setTimeout(() => {
						timedOut = true;
						try { process.kill(-child.pid!, "SIGKILL"); } catch {}
					}, options.timeout * 1000)
				: undefined;

		const onAbort = () => {
			if (child.pid) {
				try { process.kill(-child.pid, "SIGKILL"); } catch {}
			}
		};

		if (options?.signal) {
			if (options.signal.aborted) {
				onAbort();
			} else {
				options.signal.addEventListener("abort", onAbort, { once: true });
			}
		}

		child.stdout?.on("data", (data) => {
			stdout += data.toString();
			if (stdout.length > 10 * 1024 * 1024) {
				stdout = stdout.slice(0, 10 * 1024 * 1024);
			}
		});

		child.stderr?.on("data", (data) => {
			stderr += data.toString();
			if (stderr.length > 10 * 1024 * 1024) {
				stderr = stderr.slice(0, 10 * 1024 * 1024);
			}
		});

		child.on("close", (code) => {
			if (timeoutHandle) clearTimeout(timeoutHandle);
			if (options?.signal) {
				options.signal.removeEventListener("abort", onAbort);
			}

			if (options?.signal?.aborted) {
				reject(new Error(`${stdout}\n${stderr}\nCommand aborted`.trim()));
				return;
			}

			if (timedOut) {
				reject(new Error(`${stdout}\n${stderr}\nCommand timed out after ${options?.timeout} seconds`.trim()));
				return;
			}

			resolve({ stdout, stderr, code: code ?? 0 });
		});
	});
}

// ============================================================================
// Crypto API Utilities
// ============================================================================

async function getCryptoPrice(symbol: string): Promise<{ price: number; change24h: number; marketCap: number }> {
	try {
		const url = `https://api.coingecko.com/api/v3/simple/price?ids=${symbol.toLowerCase()}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true`;
		const response = await fetch(url);
		const data = await response.json();

		const symbolData = data[symbol.toLowerCase()];
		if (!symbolData) {
			throw new Error(`Symbol not found: ${symbol}`);
		}

		return {
			price: symbolData.usd,
			change24h: symbolData.usd_24h_change || 0,
			marketCap: symbolData.usd_market_cap || 0,
		};
	} catch (error) {
		throw new Error(`Failed to fetch price: ${error instanceof Error ? error.message : String(error)}`);
	}
}

async function getCryptoNews(topic?: string): Promise<Array<{ title: string; url: string; source: string }>> {
	try {
		// Using CryptoPanic free API (no key required for basic use)
		const url = topic
			? `https://cryptopanic.com/api/v1/posts/?auth_token=free&filter=${encodeURIComponent(topic)}`
			: `https://cryptopanic.com/api/v1/posts/?auth_token=free&kind=news`;

		const response = await fetch(url);
		const data = await response.json();

		if (!data.results || data.results.length === 0) {
			return [];
		}

		return data.results.slice(0, 5).map((item: any) => ({
			title: item.title,
			url: item.url,
			source: item.source?.title || "Unknown",
		}));
	} catch (error) {
		// Fallback: return empty array if API fails
		return [];
	}
}

async function convertCurrency(amount: number, from: string, to: string): Promise<{ result: number; rate: number }> {
	try {
		// Use CoinGecko for crypto conversions
		const fromLower = from.toLowerCase();
		const toLower = to.toLowerCase();

		// Get both prices in USD
		const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromLower},${toLower}&vs_currencies=usd`;
		const response = await fetch(url);
		const data = await response.json();

		const fromPrice = data[fromLower]?.usd;
		const toPrice = data[toLower]?.usd;

		if (!fromPrice || !toPrice) {
			throw new Error(`Currency not found: ${!fromPrice ? from : to}`);
		}

		const rate = fromPrice / toPrice;
		const result = amount * rate;

		return { result, rate };
	} catch (error) {
		throw new Error(`Conversion failed: ${error instanceof Error ? error.message : String(error)}`);
	}
}

function generateTradingViewLink(symbol: string, timeframe: string): string {
	// Normalize symbol (remove slashes, make uppercase)
	const normalizedSymbol = symbol.toUpperCase().replace(/[\/\-]/g, "");

	// Map common timeframes
	const timeframeMap: Record<string, string> = {
		"1m": "1",
		"5m": "5",
		"15m": "15",
		"30m": "30",
		"1h": "60",
		"4h": "240",
		"1d": "D",
		"1w": "W",
		"1M": "M",
	};

	const mappedTimeframe = timeframeMap[timeframe.toLowerCase()] || timeframe;

	return `https://www.tradingview.com/chart/?symbol=${normalizedSymbol}&interval=${mappedTimeframe}`;
}

// ============================================================================
// Truncation Utilities
// ============================================================================

function formatSize(bytes: number): string {
	if (bytes < 1024) return `${bytes}B`;
	if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
	return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
}

function truncateTail(content: string): { content: string; truncated: boolean; totalLines: number; outputLines: number } {
	const totalBytes = Buffer.byteLength(content, "utf-8");
	const lines = content.split("\n");
	const totalLines = lines.length;

	if (totalLines <= DEFAULT_MAX_LINES && totalBytes <= DEFAULT_MAX_BYTES) {
		return { content, truncated: false, totalLines, outputLines: totalLines };
	}

	const outputLines: string[] = [];
	let outputBytes = 0;

	for (let i = lines.length - 1; i >= 0 && outputLines.length < DEFAULT_MAX_LINES; i--) {
		const line = lines[i];
		const lineBytes = Buffer.byteLength(line, "utf-8") + (outputLines.length > 0 ? 1 : 0);

		if (outputBytes + lineBytes > DEFAULT_MAX_BYTES) break;

		outputLines.unshift(line);
		outputBytes += lineBytes;
	}

	return {
		content: outputLines.join("\n"),
		truncated: true,
		totalLines,
		outputLines: outputLines.length,
	};
}

// ============================================================================
// Agent Tools
// ============================================================================

const bashSchema = Type.Object({
	label: Type.String({ description: "Brief description of what this command does (shown to user)" }),
	command: Type.String({ description: "Bash command to execute" }),
	timeout: Type.Optional(Type.Number({ description: "Timeout in seconds (optional)" })),
});

function createBashTool(): AgentTool<typeof bashSchema> {
	return {
		name: "bash",
		label: "bash",
		description: `Execute a bash command. Returns stdout and stderr. Output truncated to last ${DEFAULT_MAX_LINES} lines or ${DEFAULT_MAX_BYTES / 1024}KB. Dangerous commands (sudo, rm -rf, etc.) require user approval.`,
		parameters: bashSchema,
		execute: async (_toolCallId, { command, timeout, label }, signal) => {
			logTool("bash", label);

			// Security: Check for dangerous commands and request approval
			if (isDangerousCommand(command)) {
				logWarning("Dangerous command detected, requesting approval", command.substring(0, 50));
				const approved = await requestApproval(command);
				if (!approved) {
					throw new Error("Command denied: Requires user approval for dangerous operations.");
				}
			}

			const result = await execCommand(command, { timeout, signal });
			let output = "";
			if (result.stdout) output += result.stdout;
			if (result.stderr) {
				if (output) output += "\n";
				output += result.stderr;
			}

			const truncation = truncateTail(output);
			let outputText = truncation.content || "(no output)";

			if (truncation.truncated) {
				const startLine = truncation.totalLines - truncation.outputLines + 1;
				outputText += `\n\n[Showing lines ${startLine}-${truncation.totalLines} of ${truncation.totalLines}]`;
			}

			if (result.code !== 0) {
				throw new Error(`${outputText}\n\nCommand exited with code ${result.code}`.trim());
			}

			return { content: [{ type: "text", text: outputText }], details: undefined };
		},
	};
}

const readSchema = Type.Object({
	label: Type.String({ description: "Brief description of what you're reading (shown to user)" }),
	path: Type.String({ description: "Path to the file to read" }),
	offset: Type.Optional(Type.Number({ description: "Line number to start from (1-indexed)" })),
	limit: Type.Optional(Type.Number({ description: "Maximum lines to read" })),
});

function createReadTool(): AgentTool<typeof readSchema> {
	return {
		name: "read",
		label: "read",
		description: `Read file contents. Output truncated to ${DEFAULT_MAX_LINES} lines or ${DEFAULT_MAX_BYTES / 1024}KB. Use offset/limit for large files.`,
		parameters: readSchema,
		execute: async (_toolCallId, { path, offset, limit, label }, signal) => {
			logTool("read", `${label} (${path})`);

			const countResult = await execCommand(`wc -l < ${shellEscape(path)}`, { signal });
			if (countResult.code !== 0) {
				throw new Error(countResult.stderr || `Failed to read file: ${path}`);
			}
			const totalLines = parseInt(countResult.stdout.trim(), 10) + 1;

			const startLine = offset ? Math.max(1, offset) : 1;
			let cmd = startLine === 1 ? `cat ${shellEscape(path)}` : `tail -n +${startLine} ${shellEscape(path)}`;

			const result = await execCommand(cmd, { signal });
			if (result.code !== 0) {
				throw new Error(result.stderr || `Failed to read file: ${path}`);
			}

			let content = result.stdout;

			if (limit !== undefined) {
				const lines = content.split("\n");
				content = lines.slice(0, limit).join("\n");
			}

			const truncation = truncateTail(content);
			let outputText = truncation.content;

			if (truncation.truncated) {
				const endLine = startLine + truncation.outputLines - 1;
				outputText += `\n\n[Showing lines ${startLine}-${endLine} of ${totalLines}. Use offset=${endLine + 1} to continue]`;
			}

			return { content: [{ type: "text", text: outputText }], details: undefined };
		},
	};
}

const writeSchema = Type.Object({
	label: Type.String({ description: "Brief description of what you're writing (shown to user)" }),
	path: Type.String({ description: "Path to the file to write" }),
	content: Type.String({ description: "Content to write" }),
});

function createWriteTool(): AgentTool<typeof writeSchema> {
	return {
		name: "write",
		label: "write",
		description: "Write content to a file. Creates parent directories. Overwrites existing files.",
		parameters: writeSchema,
		execute: async (_toolCallId, { path, content, label }, signal) => {
			logTool("write", `${label} (${path})`);

			const dir = path.includes("/") ? path.substring(0, path.lastIndexOf("/")) : ".";
			const cmd = `mkdir -p ${shellEscape(dir)} && printf '%s' ${shellEscape(content)} > ${shellEscape(path)}`;

			const result = await execCommand(cmd, { signal });
			if (result.code !== 0) {
				throw new Error(result.stderr || `Failed to write file: ${path}`);
			}

			return { content: [{ type: "text", text: `Successfully wrote ${content.length} bytes to ${path}` }], details: undefined };
		},
	};
}

const editSchema = Type.Object({
	label: Type.String({ description: "Brief description of the edit (shown to user)" }),
	path: Type.String({ description: "Path to the file to edit" }),
	oldText: Type.String({ description: "Exact text to find and replace" }),
	newText: Type.String({ description: "New text to replace with" }),
});

function createEditTool(): AgentTool<typeof editSchema> {
	return {
		name: "edit",
		label: "edit",
		description: "Edit a file by replacing exact text. oldText must match exactly including whitespace.",
		parameters: editSchema,
		execute: async (_toolCallId, { path, oldText, newText, label }, signal) => {
			logTool("edit", `${label} (${path})`);

			const readResult = await execCommand(`cat ${shellEscape(path)}`, { signal });
			if (readResult.code !== 0) {
				throw new Error(readResult.stderr || `File not found: ${path}`);
			}

			const content = readResult.stdout;

			if (!content.includes(oldText)) {
				throw new Error(`Could not find the exact text in ${path}. Must match exactly including whitespace.`);
			}

			const occurrences = content.split(oldText).length - 1;
			if (occurrences > 1) {
				throw new Error(`Found ${occurrences} occurrences. Text must be unique. Add more context.`);
			}

			const index = content.indexOf(oldText);
			const newContent = content.substring(0, index) + newText + content.substring(index + oldText.length);

			const writeResult = await execCommand(`printf '%s' ${shellEscape(newContent)} > ${shellEscape(path)}`, { signal });
			if (writeResult.code !== 0) {
				throw new Error(writeResult.stderr || `Failed to write file: ${path}`);
			}

			return { content: [{ type: "text", text: `Successfully edited ${path}. Changed ${oldText.length} chars to ${newText.length} chars.` }], details: undefined };
		},
	};
}

// ============================================================================
// Memory System
// ============================================================================

function getMemory(channelDir: string, workspaceDir: string): string {
	const parts: string[] = [];

	const globalMemoryPath = join(workspaceDir, "MEMORY.md");
	if (existsSync(globalMemoryPath)) {
		try {
			const content = readFileSync(globalMemoryPath, "utf-8").trim();
			if (content) parts.push("### Global Memory\n" + content);
		} catch {}
	}

	const channelMemoryPath = join(channelDir, "MEMORY.md");
	if (existsSync(channelMemoryPath)) {
		try {
			const content = readFileSync(channelMemoryPath, "utf-8").trim();
			if (content) parts.push("### Channel Memory\n" + content);
		} catch {}
	}

	return parts.length > 0 ? parts.join("\n\n") : "(no memory yet)";
}

function addToMemory(text: string, channelDir: string, workspaceDir: string, isGlobal: boolean): void {
	const memoryPath = isGlobal ? join(workspaceDir, "MEMORY.md") : join(channelDir, "MEMORY.md");
	const dir = isGlobal ? workspaceDir : channelDir;

	if (!existsSync(dir)) {
		mkdirSync(dir, { recursive: true });
	}

	const timestamp = new Date().toISOString().split("T")[0];
	const entry = `\n- [${timestamp}] ${text}`;

	if (existsSync(memoryPath)) {
		appendFileSync(memoryPath, entry);
	} else {
		writeFileSync(memoryPath, `# Memory\n${entry}`);
	}
}

function clearMemory(channelDir: string, workspaceDir: string, isGlobal: boolean): boolean {
	const memoryPath = isGlobal ? join(workspaceDir, "MEMORY.md") : join(channelDir, "MEMORY.md");

	if (existsSync(memoryPath)) {
		writeFileSync(memoryPath, "# Memory\n");
		return true;
	}
	return false;
}

// ============================================================================
// Skills System
// ============================================================================

function loadSkills(workspacePath: string): string {
	const skillsDir = join(workspacePath, "skills");
	if (!existsSync(skillsDir)) {
		return "";
	}

	const skillFiles = ["model-management.md", "quant-trading.md", "technical-analysis.md", "risk-management.md", "trading-system-monitor.md", "market-data.md"];
	const skills: string[] = [];

	for (const file of skillFiles) {
		const skillPath = join(skillsDir, file);
		if (existsSync(skillPath)) {
			try {
				const content = readFileSync(skillPath, "utf-8").trim();
				if (content) {
					skills.push(content);
				}
			} catch {
				// Ignore read errors
			}
		}
	}

	if (skills.length === 0) {
		return "";
	}

	return "\n## Skills\n" + skills.join("\n\n---\n\n");
}

// ============================================================================
// System Prompt
// ============================================================================

function buildSystemPrompt(workspacePath: string, channelId: string, channelName: string, memory: string): string {
	const channelPath = `${workspacePath}/${channelId}`;
	const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
	const skills = loadSkills(workspacePath);

	return `You are an AI assistant Discord bot with full system access. Be helpful, concise, and efficient. No emojis unless asked.

## Context
- Current time: Use \`date\` command
- Timezone: ${tz}
- You have access to bash, file read/write/edit tools
- Dangerous commands (sudo, rm -rf, etc.) require user approval via reaction

## üöÄ MAJINBU ELITE PLATFORM
You are running on a production Ubuntu 22.04 server with extensive AI and trading infrastructure:

### AI Agents (40+)
| Command | Description |
|---------|-------------|
| claude, gemini, pi | Main AI assistants |
| aider, amp, codex, goose | Coding agents |
| qwen, fabric | Specialized AI tools |
| Exa, BrightData, YouTube | MCP integrations |

### Trading Systems
| Alias | System |
|-------|--------|
| \`quant\` | Renaissance-style 20-directory quant trading |
| \`super\` | SuperQuant Elite 30-directory framework |
| \`nanoagent\` | Nano-Agent 40-directory AI ecosystem |

### Services (always running)
| Service | Port |
|---------|------|
| Coolify | :8001 |
| Dokploy | :4000 |
| n8n | :5678 |
| Grafana | :3000 |
| pi-discord (you) | via Discord |

### Ollama Models (local AI)
qwen3, devstral, mistral-small, gpt-oss-120b, deepseek-ocr, qwen3-coder

### Useful Commands
- \`orghelp\` - Navigation guide for organized directories
- \`ai list\` - List all AI agents
- \`fabric -l\` - List 233 Fabric patterns
- \`ollama list\` - Show local Ollama models
- \`su majinbu\` - Switch to majinbu user (has all aliases)

### Key Directories
- /home/majinbu/org/ - Organized directory structure
- /opt/pi-mono/ - Pi agent monorepo (your code)
- /opt/discord-bot-data/ - Your workspace

### üîß SELF-MODIFICATION (You can fix yourself!)
Your source code is at: \`/opt/pi-mono/packages/discord-bot/src/main.ts\`

**To fix bugs or add features:**
1. Read your code: \`cat /opt/pi-mono/packages/discord-bot/src/main.ts\`
2. Edit with the edit tool or write tool
3. Rebuild: \`cd /opt/pi-mono && npm run build --workspace=packages/discord-bot\`
4. Restart yourself: \`sudo systemctl restart pi-discord\`

**Important files:**
- \`/opt/pi-mono/packages/discord-bot/src/main.ts\` - Your main code
- \`/etc/systemd/system/pi-discord.service\` - Service config
- \`/opt/discord-bot-data/\` - Your workspace & memories

**Safety rules:**
- Always backup before major changes
- Test syntax with \`tsc --noEmit\` before building
- If you break yourself, owner can fix via SSH

## Discord Formatting
**bold**, *italic*, \`code\`, \`\`\`code block\`\`\`, ||spoiler||, > quote
Links: [text](url) or paste URLs directly

## Workspace Layout
${workspacePath}/
‚îú‚îÄ‚îÄ MEMORY.md                    # Global memory (all channels)
‚îú‚îÄ‚îÄ skills/                      # Loaded skills (quant trading, etc.)
‚îî‚îÄ‚îÄ ${channelId}/                # This channel (${channelName})
    ‚îú‚îÄ‚îÄ MEMORY.md                # Channel-specific memory
    ‚îú‚îÄ‚îÄ log.jsonl                # Message history
    ‚îî‚îÄ‚îÄ scratch/                 # Your working directory

## Core Tools
- **bash**: Execute shell commands (primary tool). Install packages with apt/pip/npm as needed. Dangerous commands require approval.
- **read**: Read file contents
- **write**: Create/overwrite files
- **edit**: Surgical text replacement in files

## MCP Tools (21 Tools - Claude Code Capabilities)
**IMPORTANT: When user asks to search GitHub, HuggingFace, web, or pi-mono - CALL THE TOOL DIRECTLY!**

### Web & Research (4 tools)
- **web_search**: Search web using Exa AI
- **free_search**: Free DuckDuckGo instant answers (no API key needed)
- **deep_research**: AI-powered comprehensive research
- **web_scrape**: Scrape webpages (BrightData anti-bot bypass)

### GitHub Integration (7 tools)
- **github_search**: Search GitHub repos
- **github_file**: Get file from repo
- **github_issues**: List issues
- **github_issue**: Create issue
- **github_branch**: Create branch
- **github_pr**: Create pull request
- **github_prs**: List pull requests

### HuggingFace (2 tools)
- **hf_models**: Search ML models
- **hf_datasets**: Search datasets

### Knowledge Graph Memory (3 tools)
- **memory_store**: Store facts
- **memory_recall**: Search knowledge
- **memory_relate**: Create relations

### Task Management (3 tools)
- **task_create**: Create task with dependencies
- **task_list**: List tasks by status
- **task_update**: Update task status

### Pi-Mono Codebase (1 tool)
- **codebase_knowledge**: Search pi-mono documentation and knowledge base

## üß† PI-MONO EXPERTISE
You are the official Discord bot for the pi-mono project. You have deep knowledge of:

**Packages:**
- **pi-ai**: Unified multi-provider LLM API (OpenAI, Anthropic, Google, Mistral, etc.)
- **pi-agent-core**: Agent runtime with tool calling and state management
- **pi-coding-agent**: Interactive CLI coding agent (pi command)
- **pi-mom**: Slack bot with self-managing capabilities
- **pi-discord**: This bot - your own code!
- **pi-tui**: Terminal UI library
- **pi-web-ui**: Web components for chat interfaces
- **pi-proxy**: CORS proxy for browser LLM calls
- **pi-pods**: vLLM deployment on GPU pods

**Key Concepts:**
- TypeBox schemas for type-safe tool definitions
- agentLoop/agentLoopContinue for agentic workflows
- Context serialization for persistence
- Cross-provider model handoffs
- Streaming with partial JSON parsing

When asked about pi-mono, CALL codebase_knowledge tool first!

**Tool Usage Pattern:**
- "search github for X" ‚Üí CALL github_search
- "find HF models for Y" ‚Üí CALL hf_models
- "how does pi-ai work" ‚Üí CALL codebase_knowledge
- "what is pi-agent" ‚Üí CALL codebase_knowledge
- "remember Z" ‚Üí CALL memory_store

Each tool requires a "label" parameter (shown to user).

## Memory & Self-Learning
Write important context to MEMORY.md files:
- Global (${workspacePath}/MEMORY.md): preferences, project info, installed tools
- Channel (${channelPath}/MEMORY.md): channel-specific decisions, ongoing work

### Self-Management Tools (USE THESE PROACTIVELY!)
- **memory_update**: Update your MEMORY.md with learned preferences, facts, discoveries
- **skill_create**: Create new skill files when you learn valuable domain knowledge
- **skill_list**: List available skills (32+ domains)
- **skill_load**: Load skill instructions for specific tasks

**PROACTIVE LEARNING BEHAVIOR:**
1. When a user teaches you something new ‚Üí Use memory_update to remember it
2. When you solve a complex problem ‚Üí Consider creating a skill for it
3. When asked about a domain ‚Üí Check if a skill exists first with skill_list
4. Load relevant skills to gain specialized knowledge

### Current Memory
${memory}
${skills}

## ü§ñ FULLY AGENTIC CAPABILITIES

### You are autonomous. You can:
1. **Execute ANY bash command** - You have full sudo access
2. **Search the web** - Use \`curl\`, \`wget\`, or installed tools like \`ddgr\`, \`googler\`
3. **Call APIs** - Use \`curl\` for REST APIs, you have API keys in environment
4. **Install software** - \`apt-get install\`, \`pip install\`, \`npm install\`
5. **Modify files anywhere** - Read, write, edit any file on the system
6. **Run Python/Node scripts** - Create and execute scripts for complex tasks
7. **Manage services** - \`systemctl start/stop/restart\`
8. **Self-modify** - Edit your own code and restart yourself
9. **Schedule tasks** - Use \`cron\` for recurring tasks
10. **Monitor systems** - Check logs, processes, resources

### Web & API Access (via bash)
\`\`\`bash
# Web search
curl -s "https://api.duckduckgo.com/?q=QUERY&format=json"
ddgr --json "search query"

# Fetch URLs
curl -s "https://example.com" | head -100

# OpenRouter API (you're using this!)
curl -s "https://openrouter.ai/api/v1/chat/completions" -H "Authorization: Bearer $OPENROUTER_API_KEY" ...

# Crypto prices
curl -s "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd"
\`\`\`

### Available CLI Tools
| Tool | Purpose |
|------|---------|
| \`fabric -p PATTERN\` | 233 AI patterns (summarize, extract_wisdom, etc.) |
| \`yt-dlp\` | Download YouTube videos/audio |
| \`jq\` | JSON processing |
| \`gh\` | GitHub CLI |
| \`docker\` | Container management |
| \`ollama run MODEL\` | Run local AI models |

### Agentic Workflow
1. **Understand** - Parse user intent completely
2. **Plan** - Break complex tasks into steps
3. **Execute** - Run commands, handle errors, retry if needed
4. **Verify** - Check results, validate output
5. **Learn** - Save important context to MEMORY.md
6. **Report** - Summarize what was done

### Error Recovery
- If a command fails, try alternative approaches
- Install missing dependencies automatically
- If you break something, fix it or roll back
- Always inform user of issues and solutions

### Proactive Behaviors
- Suggest improvements when you see problems
- Offer to automate repetitive tasks
- Remember user preferences across sessions
- Update your knowledge when you learn new things

## Guidelines
1. **Be autonomous** - Don't ask for permission for safe operations
2. **Use bash liberally** - It's your primary superpower
3. **Chain commands** - Pipe, loop, and script complex workflows
4. **Handle errors gracefully** - Retry, fallback, or explain
5. **Stay concise** - Discord has 2000 char limit per message
6. **Remember everything** - Write to MEMORY.md liberally
7. **Be proactive** - Suggest, warn, and improve
8. Working directory: ${channelPath}/scratch/
`;
}

// ============================================================================
// Message Logging
// ============================================================================

function logMessage(channelDir: string, entry: object): void {
	if (!existsSync(channelDir)) {
		mkdirSync(channelDir, { recursive: true });
	}
	appendFileSync(join(channelDir, "log.jsonl"), JSON.stringify(entry) + "\n");
}

// ============================================================================
// Session Persistence (JSONL)
// ============================================================================

const SESSION_FILE = "session.jsonl";
const MAX_SESSION_MESSAGES = 100; // Auto-compact after this many messages

interface SessionEntry {
	role: string;
	content: unknown;
	timestamp: string;
	[key: string]: unknown;
}

function saveSessionMessage(channelDir: string, message: unknown): void {
	if (!existsSync(channelDir)) {
		mkdirSync(channelDir, { recursive: true });
	}
	const entry: SessionEntry = {
		...(message as object),
		timestamp: new Date().toISOString(),
	} as SessionEntry;
	appendFileSync(join(channelDir, SESSION_FILE), JSON.stringify(entry) + "\n");
}

function loadSession(channelDir: string): unknown[] {
	const sessionPath = join(channelDir, SESSION_FILE);
	if (!existsSync(sessionPath)) {
		return [];
	}
	try {
		const content = readFileSync(sessionPath, "utf-8");
		const lines = content.trim().split("\n").filter(Boolean);
		const messages = lines.map((line) => {
			try {
				const parsed = JSON.parse(line);
				// Remove timestamp from loaded message (it's metadata)
				const { timestamp: _ts, ...msg } = parsed;
				return msg;
			} catch {
				return null;
			}
		}).filter(Boolean);
		logInfo(`Loaded ${messages.length} messages from session for channel`);
		return messages;
	} catch (e) {
		logError("Failed to load session", e instanceof Error ? e.message : String(e));
		return [];
	}
}

function clearSession(channelDir: string): void {
	const sessionPath = join(channelDir, SESSION_FILE);
	if (existsSync(sessionPath)) {
		unlinkSync(sessionPath);
		logInfo(`Cleared session for channel`);
	}
}

function getSessionMessageCount(channelDir: string): number {
	const sessionPath = join(channelDir, SESSION_FILE);
	if (!existsSync(sessionPath)) return 0;
	try {
		const content = readFileSync(sessionPath, "utf-8");
		return content.trim().split("\n").filter(Boolean).length;
	} catch {
		return 0;
	}
}

const KEEP_RECENT_MESSAGES = 30; // Keep this many recent messages when compacting

/**
 * Auto-compact session when it exceeds MAX_SESSION_MESSAGES.
 * Keeps the most recent KEEP_RECENT_MESSAGES and summarizes older context.
 */
function compactSessionIfNeeded(channelDir: string, agent: Agent): boolean {
	const sessionPath = join(channelDir, SESSION_FILE);
	if (!existsSync(sessionPath)) return false;

	try {
		const content = readFileSync(sessionPath, "utf-8");
		const lines = content.trim().split("\n").filter(Boolean);

		if (lines.length <= MAX_SESSION_MESSAGES) {
			return false; // No compaction needed
		}

		logInfo(`Compacting session: ${lines.length} messages -> ${KEEP_RECENT_MESSAGES} + summary`);

		// Parse all messages
		const messages = lines.map((line) => {
			try {
				const parsed = JSON.parse(line);
				const { timestamp: _ts, ...msg } = parsed;
				return msg;
			} catch {
				return null;
			}
		}).filter(Boolean);

		// Split into old (to summarize) and recent (to keep)
		const oldMessages = messages.slice(0, messages.length - KEEP_RECENT_MESSAGES);
		const recentMessages = messages.slice(-KEEP_RECENT_MESSAGES);

		// Create a summary of old messages
		const summaryText = createConversationSummary(oldMessages);

		// Create compacted session: summary + recent messages
		const compactedLines: string[] = [];

		// Add summary as a system context message
		const summaryMessage = {
			role: "user",
			content: [{ type: "text", text: `[PREVIOUS CONTEXT SUMMARY]\n${summaryText}\n[END SUMMARY - Recent conversation follows]` }],
			timestamp: new Date().toISOString(),
			isCompactedSummary: true,
		};
		compactedLines.push(JSON.stringify(summaryMessage));

		// Add recent messages
		for (const msg of recentMessages) {
			compactedLines.push(JSON.stringify({ ...msg, timestamp: new Date().toISOString() }));
		}

		// Write compacted session
		writeFileSync(sessionPath, compactedLines.join("\n") + "\n");

		// Update agent's messages to match
		const loadedMessages = loadSession(channelDir);
		agent.replaceMessages(loadedMessages as Parameters<typeof agent.replaceMessages>[0]);

		logInfo(`Session compacted: ${lines.length} -> ${compactedLines.length} messages`);
		return true;
	} catch (e) {
		logError("Failed to compact session", e instanceof Error ? e.message : String(e));
		return false;
	}
}

/**
 * Create a text summary of old conversation messages.
 */
function createConversationSummary(messages: unknown[]): string {
	const summary: string[] = [];
	let userCount = 0;
	let assistantCount = 0;
	const topics: string[] = [];

	for (const msg of messages) {
		const m = msg as { role?: string; content?: unknown };
		if (m.role === "user") {
			userCount++;
			// Extract topic hints from user messages
			const content = m.content;
			if (Array.isArray(content)) {
				for (const c of content) {
					if (typeof c === "object" && c !== null && "text" in c && typeof c.text === "string") {
						const text = c.text.substring(0, 100);
						if (text.length > 20 && !text.startsWith("[")) {
							topics.push(text.split("\n")[0]);
						}
					}
				}
			}
		} else if (m.role === "assistant") {
			assistantCount++;
		}
	}

	summary.push(`Previous conversation: ${userCount} user messages, ${assistantCount} assistant responses.`);

	if (topics.length > 0) {
		// Take up to 5 unique topic snippets
		const uniqueTopics = [...new Set(topics)].slice(0, 5);
		summary.push(`Topics discussed: ${uniqueTopics.join(" | ")}`);
	}

	return summary.join("\n");
}

// ============================================================================
// Channel State
// ============================================================================

interface ChannelState {
	running: boolean;
	agent: Agent;
}

const channelStates = new Map<string, ChannelState>();

// Message deduplication - track processed message IDs to prevent double responses
const processedMessages = new Set<string>();
const MESSAGE_CACHE_TTL = 60000; // 1 minute

function markMessageProcessed(messageId: string): boolean {
	if (processedMessages.has(messageId)) {
		return false; // Already processed
	}
	processedMessages.add(messageId);
	// Auto-cleanup after TTL
	setTimeout(() => processedMessages.delete(messageId), MESSAGE_CACHE_TTL);
	return true; // OK to process
}

function getChannelState(channelId: string, workingDir: string, channelName: string): ChannelState {
	let state = channelStates.get(channelId);
	if (!state) {
		const channelDir = join(workingDir, channelId);
		const memory = getMemory(channelDir, workingDir);
		const systemPrompt = buildSystemPrompt(workingDir, channelId, channelName, memory);

		const tools = [
			createBashTool(),
			createReadTool(),
			createWriteTool(),
			createEditTool(),
			...getAllMcpTools(), // MCP tools: web_search, github, hf, memory
		];

		const agent = new Agent({
			initialState: {
				systemPrompt,
				model,
				thinkingLevel: "off",
				tools,
			},
			transport: new ProviderTransport({
				getApiKey: async () => {
					// Return appropriate API key based on provider
					if (currentProvider === "openrouter") {
						return OPENROUTER_API_KEY;
					}
					return "ollama"; // Ollama doesn't need real API key
				},
			}),
		});

		// Load session history if exists
		const sessionMessages = loadSession(channelDir);
		if (sessionMessages.length > 0) {
			agent.replaceMessages(sessionMessages as Parameters<typeof agent.replaceMessages>[0]);
			logInfo(`Restored ${sessionMessages.length} messages for channel ${channelId}`);
		}

		state = { running: false, agent };
		channelStates.set(channelId, state);
	}
	return state;
}

// ============================================================================
// Response Handler (shared between slash commands and mentions)
// ============================================================================

async function handleAgentRequest(
	channelId: string,
	channelName: string,
	userName: string,
	userId: string,
	text: string,
	workingDir: string,
	reply: (content: string) => Promise<any>,
	editReply: (content: string) => Promise<any>,
	sourceMessage: Message | null = null,
): Promise<void> {
	// User allowlist check
	if (!isUserAllowed(userId)) {
		await reply("_Access denied. You are not authorized to use this bot._");
		logWarning(`Unauthorized user attempt: ${userName}`, userId);
		return;
	}

	// Rate limiting check
	const rateLimit = checkRateLimit(userId);
	if (!rateLimit.allowed) {
		const resetSecs = Math.ceil(rateLimit.resetIn / 1000);
		await reply(`_Rate limited. Try again in ${resetSecs}s._`);
		logWarning(`Rate limited user ${userName}`, `reset in ${resetSecs}s`);
		return;
	}

	const channelDir = join(workingDir, channelId);

	// Track statistics
	botStats.messagesProcessed++;
	trackUserInteraction(userId, userName);

	logMessage(channelDir, {
		date: new Date().toISOString(),
		user: userName,
		userId: userId,
		text,
		isBot: false,
	});

	const state = getChannelState(channelId, workingDir, channelName);

	// Use a simple queue - if already running, silently skip (don't send "already working" message)
	if (state.running) {
		logWarning(`Channel ${channelId} already processing, queuing request`);
		// Wait briefly for previous request to finish
		await new Promise(resolve => setTimeout(resolve, 2000));
		if (state.running) {
			// Still running after wait - skip silently to avoid spam
			logWarning(`Channel ${channelId} still busy, skipping request`);
			return;
		}
	}

	state.running = true;
	let toolsUsed: string[] = [];
	const startTime = Date.now();

	// Set approval context for dangerous command checks
	setApprovalContext(sourceMessage, userId);

	// ==========================================================================
	// AUTO-TOOL DETECTION: Intercept common requests and call tools directly
	// ==========================================================================
	const textLower = text.toLowerCase();
	let autoToolResult: string | null = null;

	try {
		// GitHub search detection - many natural patterns
		const githubPatterns = [
			/(?:search|find|look for|show me|get)(?: on| in)? github(?: for)?\s+(.+)/i,
			/github (?:repos?|repositories|projects)(?: for| about| on)?\s+(.+)/i,
			/(?:any|best|top|good) (?:repos?|repositories|projects)(?: for| about| on)?\s+(.+)/i,
			/(?:find|show|list) (?:repos?|repositories)(?: for| about)?\s+(.+)/i,
		];

		for (const pattern of githubPatterns) {
			const match = text.match(pattern);
			if (match && !textLower.includes("how to")) {
				const query = match[1].trim();
				logInfo(`[AUTO-TOOL] github_search: ${query}`);
				const tool = createGithubRepoSearchTool();
				const result = await tool.execute("auto", { query, perPage: 5, label: `GitHub: "${query}"` });
				const firstContent = result.content?.[0];
				if (firstContent && firstContent.type === "text" && firstContent.text) {
					autoToolResult = firstContent.text;
					toolsUsed.push("github_search");
				}
				break;
			}
		}

		// HuggingFace model search - natural patterns
		if (!autoToolResult) {
			const hfModelPatterns = [
				/(?:find|search|show|get|list)(?: me)?(?: huggingface| hf)? models?(?: for| about| on)?\s+(.+)/i,
				/(?:huggingface|hf) models?(?: for| about)?\s+(.+)/i,
				/(?:any|best|top) (?:ai |ml |machine learning )?models?(?: for| about)?\s+(.+)/i,
				/models? for\s+(.+)/i,
			];

			for (const pattern of hfModelPatterns) {
				const match = text.match(pattern);
				if (match && !textLower.includes("how to")) {
					const query = match[1].trim();
					logInfo(`[AUTO-TOOL] hf_models: ${query}`);
					const tool = createHfModelSearchTool();
					const result = await tool.execute("auto", { query, limit: 5, label: `HF Models: "${query}"` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("hf_models");
					}
					break;
				}
			}
		}

		// HuggingFace dataset search
		if (!autoToolResult) {
			const hfDatasetPatterns = [
				/(?:find|search|show|get|list)(?: me)?(?: huggingface| hf)? datasets?(?: for| about| on)?\s+(.+)/i,
				/(?:huggingface|hf) datasets?(?: for| about)?\s+(.+)/i,
				/(?:any|best|top) datasets?(?: for| about)?\s+(.+)/i,
				/datasets? for\s+(.+)/i,
			];

			for (const pattern of hfDatasetPatterns) {
				const match = text.match(pattern);
				if (match) {
					const query = match[1].trim();
					logInfo(`[AUTO-TOOL] hf_datasets: ${query}`);
					const tool = createHfDatasetSearchTool();
					const result = await tool.execute("auto", { query, limit: 5, label: `HF Datasets: "${query}"` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("hf_datasets");
					}
					break;
				}
			}
		}

		// Memory recall - natural patterns
		if (!autoToolResult) {
			const memoryPatterns = [
				/what do you (?:remember|know|recall) about\s+(.+)/i,
				/(?:recall|search|check)(?: your)? memory(?: for| about)?\s*(.+)?/i,
				/do you remember\s+(.+)/i,
				/what (?:have i|did i) (?:told|tell|said|say) (?:you )about\s+(.+)/i,
			];

			for (const pattern of memoryPatterns) {
				const match = text.match(pattern);
				if (match) {
					const query = match[1]?.trim() || "everything";
					logInfo(`[AUTO-TOOL] memory_recall: ${query}`);
					const tool = createMemoryRecallTool();
					const result = await tool.execute("auto", { query, label: `Memory: "${query}"` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("memory_recall");
					}
					break;
				}
			}
		}

		// Memory store - detect when user wants to save something
		if (!autoToolResult) {
			const storePatterns = [
				/(?:remember|save|store|note)(?: that| this)?[:\s]+(.+)/i,
				/(?:my|i) (?:name is|am|prefer|like|use|work (?:on|with)|live in)\s+(.+)/i,
			];

			for (const pattern of storePatterns) {
				const match = text.match(pattern);
				if (match && textLower.includes("remember")) {
					const fact = match[1].trim();
					logInfo(`[AUTO-TOOL] memory_store: ${fact}`);
					const tool = createMemoryStoreTool();
					const result = await tool.execute("auto", {
						entityName: userName,
						entityType: "user",
						observations: [fact],
						label: `Storing: "${fact.substring(0, 30)}..."`
					});
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("memory_store");
					}
					break;
				}
			}
		}

		// Web scraping - detect URL fetching requests
		if (!autoToolResult) {
			const scrapePatterns = [
				/(?:scrape|fetch|get|read|extract)(?: content| data| from)?\s+(https?:\/\/[^\s]+)/i,
				/(?:what(?:'s| is) (?:on|at)|show me|open)\s+(https?:\/\/[^\s]+)/i,
			];

			for (const pattern of scrapePatterns) {
				const match = text.match(pattern);
				if (match) {
					const url = match[1].trim();
					logInfo(`[AUTO-TOOL] web_scrape: ${url}`);
					const tool = createWebScrapeTool();
					const result = await tool.execute("auto", { url, label: `Scraping: ${url.substring(0, 40)}...` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("web_scrape");
					}
					break;
				}
			}
		}

		// GitHub issues - list issues from a repo
		if (!autoToolResult) {
			const issuePatterns = [
				/(?:list|show|get)(?: open| all)? issues (?:in|on|for|from)\s+([^\s]+\/[^\s]+)/i,
				/issues (?:in|on|for)\s+([^\s]+\/[^\s]+)/i,
			];

			for (const pattern of issuePatterns) {
				const match = text.match(pattern);
				if (match) {
					const [owner, repo] = match[1].split("/");
					logInfo(`[AUTO-TOOL] github_issues: ${owner}/${repo}`);
					const tool = createGithubListIssuesTool();
					const result = await tool.execute("auto", { owner, repo, state: "open", label: `Issues: ${owner}/${repo}` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("github_issues");
					}
					break;
				}
			}
		}

		// Task management - list tasks
		if (!autoToolResult && (textLower.includes("my tasks") || textLower.includes("list tasks") || textLower.includes("show tasks") || textLower.includes("todo") || textLower.includes("what are my tasks"))) {
			logInfo(`[AUTO-TOOL] task_list`);
			const tool = createTaskListTool();
			const result = await tool.execute("auto", { label: "Listing tasks" });
			const firstContent = result.content?.[0];
			if (firstContent && firstContent.type === "text" && firstContent.text) {
				autoToolResult = firstContent.text;
				toolsUsed.push("task_list");
			}
		}

		// Task create - add a new task
		if (!autoToolResult) {
			const taskPatterns = [
				/(?:add|create|new) task[:\s]+(.+)/i,
				/(?:todo|task)[:\s]+(.+)/i,
			];

			for (const pattern of taskPatterns) {
				const match = text.match(pattern);
				if (match && (textLower.includes("add") || textLower.includes("create") || textLower.includes("new"))) {
					const title = match[1].trim();
					logInfo(`[AUTO-TOOL] task_create: ${title}`);
					const tool = createTaskCreateTool();
					const result = await tool.execute("auto", {
						title,
						description: title,
						label: `Creating task: "${title.substring(0, 30)}..."`
					});
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("task_create");
					}
					break;
				}
			}
		}

		// Codebase knowledge - pi-mono questions
		if (!autoToolResult) {
			const codebasePatterns = [
				/(?:how does|what is|explain|tell me about|describe)(?: the)?\s+(pi-?\s*(?:ai|agent|coding|mom|tui|web|proxy|pods|discord|mono))/i,
				/(?:how to|how do i)(?: use)?\s+(pi-?\s*(?:ai|agent|coding|mom|tui|web|proxy|pods|discord|mono))/i,
				/what (?:are|is)(?: the)?\s+(?:packages?|components?|architecture)\s+(?:in|of)\s+pi-?mono/i,
				/pi-?mono\s+(?:packages?|architecture|overview|structure)/i,
				/(?:agentLoop|agentLoopContinue|getModel|stream|complete|Tool|Context)\s+(?:api|usage|how)/i,
			];

			for (const pattern of codebasePatterns) {
				if (pattern.test(text)) {
					const query = text.match(/(?:about|explain|what is|how does|how to)\s+(.+)/i)?.[1] || text;
					logInfo(`[AUTO-TOOL] codebase_knowledge: ${query.substring(0, 50)}...`);
					const tool = createCodebaseKnowledgeTool();
					const result = await tool.execute("auto", { query: query.trim(), label: `Codebase: "${query.substring(0, 30)}..."` });
					const firstContent = result.content?.[0];
					if (firstContent && firstContent.type === "text" && firstContent.text) {
						autoToolResult = firstContent.text;
						toolsUsed.push("codebase_knowledge");
					}
					break;
				}
			}
		}

		// Skills - list available skills
		if (!autoToolResult && (textLower.includes("list skills") || textLower.includes("what skills") || textLower.includes("show skills") || textLower.includes("available skills"))) {
			logInfo(`[AUTO-TOOL] skill_list`);
			const tool = createSkillListTool();
			const result = await tool.execute("auto", { label: "Listing skills" });
			const firstContent = result.content?.[0];
			if (firstContent && firstContent.type === "text" && firstContent.text) {
				autoToolResult = firstContent.text;
				toolsUsed.push("skill_list");
			}
		}

		// Skills - load a specific skill
		if (!autoToolResult) {
			const skillLoadPatterns = [
				/(?:load|activate|use|enable)\s+(?:the\s+)?(\S+)\s+skill/i,
				/skill[:\s]+(\S+)/i,
				/(?:how do i|help me with|teach me)\s+(\S+)/i,
			];

			for (const pattern of skillLoadPatterns) {
				const match = text.match(pattern);
				if (match) {
					const skillName = match[1].toLowerCase().replace(/['"]/g, "");
					// Check if this looks like a skill name (not a generic word)
					const skillKeywords = ["trading", "crypto", "coding", "research", "analysis", "pi-", "integration", "webhook", "api", "admin", "system"];
					if (skillKeywords.some(k => skillName.includes(k)) || skillName.startsWith("pi")) {
						logInfo(`[AUTO-TOOL] skill_load: ${skillName}`);
						const tool = createSkillLoadTool();
						const result = await tool.execute("auto", { skill: skillName, label: `Loading skill: ${skillName}` });
						const firstContent = result.content?.[0];
						if (firstContent && firstContent.type === "text" && firstContent.text) {
							autoToolResult = firstContent.text;
							toolsUsed.push("skill_load");
						}
						break;
					}
				}
			}
		}
	} catch (autoToolError) {
		logWarning(`[AUTO-TOOL] Error: ${autoToolError}`);
	}

	// If auto-tool found a result, let AI format/enhance it
	if (autoToolResult) {
		// Inject tool result into the message for AI to format nicely
		text = `User asked: "${text}"\n\nI found this data:\n${autoToolResult}\n\nPlease provide a helpful, concise response based on this data. Format nicely for Discord.`;
		logInfo(`[${channelName}] AUTO-TOOL enriched prompt with ${toolsUsed.join(", ")} results`);
	}

	try {
		// Note: For DMs, we don't edit - just send response at the end

		// Update model based on user preference
		const userModel = getUserModel(userId);
		state.agent.state.model = userModel;

		const memory = getMemory(channelDir, workingDir);
		const systemPrompt = buildSystemPrompt(workingDir, channelId, channelName, memory);
		state.agent.setSystemPrompt(systemPrompt);

		// Streaming state
		let streamingText = "";
		let lastUpdateTime = 0;
		let pendingUpdate = false;
		let isThinking = true;
		const UPDATE_THROTTLE_MS = 500;
		const MAX_DISCORD_LENGTH = 2000;

		// Show initial "thinking..." indicator
		await editReply("_thinking..._").catch(() => {});

		const unsubscribe = state.agent.subscribe((event: AgentEvent) => {
			if (event.type === "tool_execution_start") {
				const e = event as any;
				const label = e.args?.label || e.toolName;
				toolsUsed.push(`‚Üí ${label}`);
				// Don't call editReply here - we'll include tool info in final response
			}

			// Handle streaming text updates
			if (event.type === "message_update") {
				const assistantEvent = event.assistantMessageEvent;

				// On first text, clear the "thinking..." message
				if (isThinking && assistantEvent.type === "text_start") {
					isThinking = false;
					streamingText = "";
				}

				// Accumulate text deltas
				if (assistantEvent.type === "text_delta") {
					streamingText += assistantEvent.delta;

					// Throttle updates to avoid Discord rate limits
					const now = Date.now();
					if (!pendingUpdate && now - lastUpdateTime >= UPDATE_THROTTLE_MS) {
						pendingUpdate = true;
						lastUpdateTime = now;

						// Update with current streaming text (truncate if needed)
						const displayText = streamingText.length <= MAX_DISCORD_LENGTH
							? streamingText
							: streamingText.substring(0, MAX_DISCORD_LENGTH - 50) + "\n\n_(streaming...)_";

						editReply(displayText).catch(() => {}).finally(() => {
							pendingUpdate = false;
						});
					}
				}
			}
		});

		const timestamp = new Date().toISOString();
		const userMessage = `[${timestamp}] [${userName}]: ${text}`;

		// Use retry with exponential backoff for resilience
		await withRetry(
			() => state.agent.prompt(userMessage),
			{ maxRetries: 3, initialDelay: 1000, maxDelay: 10000 }
		);
		unsubscribe();

		const messages = state.agent.state.messages;

		// Get ALL assistant messages from this turn (there may be multiple if tools were used)
		// Find messages after the last user message
		const lastUserIdx = messages.map((m, i) => m.role === "user" ? i : -1).filter(i => i >= 0).pop() || 0;
		const assistantMessages = messages.slice(lastUserIdx + 1).filter((m) => m.role === "assistant");

		// Combine all text from all assistant messages in this turn
		const allTextBlocks: string[] = [];
		for (const msg of assistantMessages) {
			const textParts = msg.content
				.filter((c): c is { type: "text"; text: string } => c.type === "text")
				.map((c) => c.text);
			allTextBlocks.push(...textParts);
		}

		// Only use the LAST text block to avoid duplicate responses
		const responseText = allTextBlocks.length > 0 ? allTextBlocks[allTextBlocks.length - 1] : "";

		if (responseText.trim()) {
			logMessage(channelDir, {
				date: new Date().toISOString(),
				user: "bot",
				text: responseText,
				toolsUsed,
				isBot: true,
			});

			// Save session for persistence (save all new messages since last save)
			const allMessages = state.agent.state.messages;
			const sessionCount = getSessionMessageCount(channelDir);
			// Save only new messages (those beyond what we've already saved)
			for (let i = sessionCount; i < allMessages.length; i++) {
				saveSessionMessage(channelDir, allMessages[i]);
			}

			// Auto-compact if session is too long
			compactSessionIfNeeded(channelDir, state.agent);

			// Track cost (estimate tokens from text length: ~4 chars per token)
			const inputTokensEst = Math.ceil(text.length / 4);
			const outputTokensEst = Math.ceil(responseText.length / 4);
			const costResult = analytics.trackCost({
				userId,
				username: userName,
				tokensInput: inputTokensEst,
				tokensOutput: outputTokensEst,
				model: state.agent.state.model.id,
				timestamp: new Date().toISOString(),
			});

			// Send alert if threshold exceeded
			if (costResult.alert) {
				logWarning(`[COST ALERT] ${costResult.alertMessage}`);
				// Could also DM the user or post to a monitoring channel
			}

			// Discord limit is 2000 chars
			const MAX_LENGTH = 2000;
			if (responseText.length <= MAX_LENGTH) {
				await editReply(responseText);
			} else {
				// Truncate for slash command response
				await editReply(responseText.substring(0, MAX_LENGTH - 50) + "\n\n_(truncated)_");
			}

			logInfo(`[${channelName}] Responded (${responseText.length} chars, ${toolsUsed.length} tools)`);

			// Track successful command
			const responseTime = Date.now() - startTime;
			analytics.trackCommand({
				type: "response",
				timestamp: new Date().toISOString(),
				userId,
				username: userName,
				command: "ask",
				responseTime,
				model: state.agent.state.model.id,
				channelId,
				channelName,
			});
		} else {
			await editReply("_Done (no text response)_");
		}
	} catch (error) {
		const errMsg = error instanceof Error ? error.message : String(error);
		botStats.errorsCount++;
		logError("Error processing request", errMsg);

		// Track error
		analytics.trackCommand({
			type: "error",
			timestamp: new Date().toISOString(),
			userId,
			username: userName,
			command: "ask",
			error: errMsg,
			model: state.agent.state.model?.id || model.id,
			channelId,
			channelName,
		});

		await editReply(`_Error: ${errMsg.substring(0, 500)}_`).catch(() => {});
	} finally {
		state.running = false;
	}
}

// ============================================================================
// Main
// ============================================================================

async function main() {
	const { workingDir } = parseArgs();

	if (!DISCORD_BOT_TOKEN) {
		logError("Missing DISCORD_BOT_TOKEN environment variable");
		process.exit(1);
	}

	if (!existsSync(workingDir)) {
		mkdirSync(workingDir, { recursive: true });
	}

	logInfo(`Starting Pi Discord Bot (agentic mode) with workspace: ${workingDir}`);
	logInfo(`Model: ${model.id}`);

	// Initialize analytics
	analytics = new Analytics(workingDir);
	logInfo("Analytics initialized");

	// Initialize database
	const dbPath = join(workingDir, "bot.db");
	db = initDatabase(dbPath);
	logInfo(`Database initialized at ${dbPath}`);

	const client = new Client({
		intents: [
			GatewayIntentBits.Guilds,
			GatewayIntentBits.GuildMessages,
			GatewayIntentBits.MessageContent,
			GatewayIntentBits.DirectMessages,
			GatewayIntentBits.GuildMessageReactions,
			GatewayIntentBits.DirectMessageReactions,
		],
		partials: [Partials.Channel, Partials.Reaction, Partials.Message],
	});

	// Register slash commands on ready (clientReady in discord.js v15+)
	client.once("clientReady", async () => {
		logInfo(`Logged in as ${client.user?.tag}`);
		logInfo(`Bot ID: ${client.user?.id}`);

		// Register slash commands globally
		try {
			const rest = new REST({ version: "10" }).setToken(DISCORD_BOT_TOKEN!);

			logInfo("Registering slash commands...");
			await rest.put(Routes.applicationCommands(client.user!.id), {
				body: slashCommands.map((cmd) => cmd.toJSON()),
			});
			logInfo(`Registered ${slashCommands.length} slash commands: /${slashCommands.map(c => c.name).join(", /")}`);
		} catch (error) {
			logError("Failed to register slash commands", error instanceof Error ? error.message : String(error));
		}

		logInfo("Ready! Supports both /commands and @mentions");

		// Graceful shutdown handler
		const shutdown = async (signal: string) => {
			logInfo(`Received ${signal}, shutting down gracefully...`);

			// Save any pending state
			try {
				for (const [channelId, state] of channelStates) {
					if (state.agent) {
						logInfo(`Saving state for channel ${channelId}`);
					}
				}
			} catch (e) {
				logError("Error during shutdown", e instanceof Error ? e.message : String(e));
			}

			// Close Discord client
			client.destroy();
			logInfo("Discord client disconnected");

			// Save analytics
			if (analytics) {
				logInfo("Saving analytics...");
			}

			logInfo("Shutdown complete");
			process.exit(0);
		};

		process.on("SIGTERM", () => shutdown("SIGTERM"));
		process.on("SIGINT", () => shutdown("SIGINT"));

		// Uncaught exception handler
		process.on("uncaughtException", (error) => {
			logError("Uncaught exception", error.message);
			console.error(error.stack);
			// Don't exit - let the process continue
		});

		process.on("unhandledRejection", (reason) => {
			logError("Unhandled rejection", String(reason));
			// Don't exit - let the process continue
		});
	});

	// Handle slash commands
	client.on("interactionCreate", async (interaction) => {
		if (!interaction.isChatInputCommand()) return;

		// Deduplicate interactions
		if (!markMessageProcessed(interaction.id)) {
			logWarning(`Duplicate interaction detected, skipping: ${interaction.id}`);
			return;
		}

		const { commandName, user, channelId } = interaction;
		const channel = interaction.channel;
		const channelName = channel && "name" in channel ? (channel as TextChannel).name : `DM:${user.username}`;

		logSlash(commandName, user.username);

		// Track statistics
		botStats.commandsProcessed++;
		trackUserInteraction(user.id, user.username);

		const channelDir = join(workingDir, channelId);
		const commandStartTime = Date.now();

		try {
			switch (commandName) {
				case "ask": {
					const question = interaction.options.getString("question", true);
					await interaction.deferReply();

					// Track if we've responded to prevent duplicates
					let hasResponded = false;
					const safeEditReply = async (content: string) => {
						if (hasResponded) return;
						hasResponded = true;
						await interaction.editReply(content);
					};

					await handleAgentRequest(
						channelId,
						channelName,
						user.username,
						user.id,
						question,
						workingDir,
						safeEditReply,  // Both use the same safe function
						safeEditReply,
						null,  // No source message for slash commands
					);
					break;
				}

				case "bash": {
					const command = interaction.options.getString("command", true);
					const timeout = interaction.options.getInteger("timeout") || undefined;

					await interaction.deferReply();

					try {
						const result = await execCommand(command, { timeout });
						let output = result.stdout || result.stderr || "(no output)";

						if (result.code !== 0) {
							output += `\n\nExit code: ${result.code}`;
						}

						// Truncate for Discord
						if (output.length > 1900) {
							output = output.substring(0, 1900) + "\n...(truncated)";
						}

						await interaction.editReply(`\`\`\`\n${output}\n\`\`\``);
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error: ${errMsg.substring(0, 500)}`);
					}
					break;
				}

				case "read": {
					const path = interaction.options.getString("path", true);
					const lines = interaction.options.getInteger("lines") || 50;

					await interaction.deferReply();

					try {
						const result = await execCommand(`head -n ${lines} ${shellEscape(path)}`);
						if (result.code !== 0) {
							await interaction.editReply(`Error: ${result.stderr || "Failed to read file"}`);
							return;
						}

						let output = result.stdout || "(empty file)";
						if (output.length > 1900) {
							output = output.substring(0, 1900) + "\n...(truncated)";
						}

						await interaction.editReply(`**${path}** (first ${lines} lines):\n\`\`\`\n${output}\n\`\`\``);
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error: ${errMsg.substring(0, 500)}`);
					}
					break;
				}

				case "remember": {
					const text = interaction.options.getString("text", true);
					const isGlobal = interaction.options.getBoolean("global") || false;

					addToMemory(text, channelDir, workingDir, isGlobal);

					await interaction.reply(`Remembered${isGlobal ? " (global)" : ""}: ${text}`);
					break;
				}

				case "memory": {
					const memory = getMemory(channelDir, workingDir);

					if (memory.length > 1900) {
						await interaction.reply(memory.substring(0, 1900) + "\n...(truncated)");
					} else {
						await interaction.reply(memory || "No memories yet.");
					}
					break;
				}

				case "forget": {
					const isGlobal = interaction.options.getBoolean("global") || false;
					const cleared = clearMemory(channelDir, workingDir, isGlobal);

					if (cleared) {
						await interaction.reply(`Cleared ${isGlobal ? "global" : "channel"} memory.`);
					} else {
						await interaction.reply(`No ${isGlobal ? "global" : "channel"} memory to clear.`);
					}
					break;
				}

				case "status": {
					const uptime = process.uptime();
					const hours = Math.floor(uptime / 3600);
					const mins = Math.floor((uptime % 3600) / 60);
					const uptimeStr = `${hours}h ${mins}m`;

					const currentModelId = getCurrentModelId(user.id);
					const statusEmbed = createStatusEmbed(currentModelId, globalModelId, uptimeStr, workingDir, channelStates.size);
					await interaction.reply({ embeds: [statusEmbed] });
					break;
				}

				case "skills": {
					// Use the new skill_list tool to get dynamic skills
					const skillListTool = createSkillListTool();
					const result = await skillListTool.execute("skills-cmd", { label: "List skills", category: undefined });

					let skillsList = "";
					if (result.content && result.content[0] && result.content[0].type === "text") {
						skillsList = result.content[0].text;
					}

					// Add capabilities info
					skillsList += "\n\n**Core Capabilities:**\n";
					skillsList += "‚Ä¢ Multi-model AI (OpenRouter + Ollama)\n";
					skillsList += "‚Ä¢ 25+ MCP tools (web, GitHub, HuggingFace, memory)\n";
					skillsList += "‚Ä¢ Pi-mono codebase knowledge\n";
					skillsList += "‚Ä¢ Persistent memory & task management\n";
					skillsList += "\n**Security:**\n";
					skillsList += "‚Ä¢ Rate limited: 10 req/min per user\n";
					skillsList += "‚Ä¢ Dangerous commands require approval\n";
					skillsList += "\n**Tip:** Use `skill_load` tool to activate a skill's instructions.";

					// Truncate if too long for Discord
					if (skillsList.length > 1900) {
						skillsList = skillsList.substring(0, 1900) + "\n...(truncated)";
					}

					await interaction.reply(skillsList);
					break;
				}

				case "price": {
					const symbol = interaction.options.getString("symbol", true);
					await interaction.deferReply();

					try {
						const priceData = await getCryptoPrice(symbol);
						const changeEmoji = priceData.change24h >= 0 ? "üìà" : "üìâ";
						const changeColor = priceData.change24h >= 0 ? "+" : "";

						const embed = new EmbedBuilder()
							.setColor(priceData.change24h >= 0 ? 0x00FF00 : 0xFF0000)
							.setTitle(`${symbol.toUpperCase()} Price`)
							.addFields(
								{ name: "Price", value: `$${priceData.price.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, inline: true },
								{ name: "24h Change", value: `${changeEmoji} ${changeColor}${priceData.change24h.toFixed(2)}%`, inline: true },
								{ name: "Market Cap", value: `$${(priceData.marketCap / 1e9).toFixed(2)}B`, inline: true }
							)
							.setTimestamp()
							.setFooter({ text: "Data from CoinGecko" });

						await interaction.editReply({ embeds: [embed] });
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error: ${errMsg}`);
					}
					break;
				}

				case "alert": {
					const condition = interaction.options.getString("condition", true);

					// Parse condition (simple format: SYMBOL > PRICE or SYMBOL < PRICE)
					const match = condition.match(/(\w+)\s*([><])\s*([\d.]+)/i);
					if (!match) {
						await interaction.reply("Invalid condition format. Use: `SYMBOL > PRICE` or `SYMBOL < PRICE`\nExample: `BTC > 50000`");
						break;
					}

					const [, symbol, operator, price] = match;

					// Store alert in memory
					const alertText = `Price alert: ${symbol.toUpperCase()} ${operator} $${price}`;
					addToMemory(alertText, channelDir, workingDir, false);

					await interaction.reply(
						`Alert set: ${symbol.toUpperCase()} ${operator} $${price}\n\n` +
						`Note: This is stored in memory. Use /ask to request monitoring of this alert, or integrate with external monitoring tools.`
					);
					break;
				}

				case "news": {
					const topic = interaction.options.getString("topic") || undefined;
					await interaction.deferReply();

					try {
						const newsItems = await getCryptoNews(topic);

						if (newsItems.length === 0) {
							await interaction.editReply("No news found. Try again later or use a different topic.");
							break;
						}

						const embed = new EmbedBuilder()
							.setColor(0x0099FF)
							.setTitle(topic ? `Crypto News: ${topic}` : "Latest Crypto News")
							.setDescription(
								newsItems.map((item, i) => `**${i + 1}. ${item.title}**\n[Read more](${item.url}) - ${item.source}`).join("\n\n")
							)
							.setTimestamp()
							.setFooter({ text: "Data from CryptoPanic" });

						await interaction.editReply({ embeds: [embed] });
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error fetching news: ${errMsg}`);
					}
					break;
				}

				case "chart": {
					const symbol = interaction.options.getString("symbol", true);
					const timeframe = interaction.options.getString("timeframe", true);

					const chartUrl = generateTradingViewLink(symbol, timeframe);

					const embed = new EmbedBuilder()
						.setColor(0x0099FF)
						.setTitle(`${symbol.toUpperCase()} Chart (${timeframe})`)
						.setDescription(`[Open in TradingView](${chartUrl})`)
						.addFields(
							{ name: "Symbol", value: symbol.toUpperCase(), inline: true },
							{ name: "Timeframe", value: timeframe, inline: true }
						)
						.setTimestamp()
						.setFooter({ text: "TradingView Chart" });

					await interaction.reply({ embeds: [embed] });
					break;
				}

				case "convert": {
					const amount = interaction.options.getNumber("amount", true);
					const from = interaction.options.getString("from", true);
					const to = interaction.options.getString("to", true);

					await interaction.deferReply();

					try {
						const conversion = await convertCurrency(amount, from, to);

						const embed = new EmbedBuilder()
							.setColor(0x0099FF)
							.setTitle("Currency Conversion")
							.addFields(
								{ name: "From", value: `${amount.toLocaleString()} ${from.toUpperCase()}`, inline: true },
								{ name: "To", value: `${conversion.result.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 8 })} ${to.toUpperCase()}`, inline: true },
								{ name: "Rate", value: `1 ${from.toUpperCase()} = ${conversion.rate.toFixed(8)} ${to.toUpperCase()}`, inline: false }
							)
							.setTimestamp()
							.setFooter({ text: "Data from CoinGecko" });

						await interaction.editReply({ embeds: [embed] });
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error: ${errMsg}`);
					}
					break;
				}

				case "model": {
					const subcommand = interaction.options.getSubcommand();

					switch (subcommand) {
						case "list": {
							await interaction.deferReply();

							try {
								const models = await fetchOllamaModels();

								if (models.length === 0) {
									await interaction.editReply("No models found. Make sure Ollama is running.");
									break;
								}

								const currentModelId = getCurrentModelId(user.id);
								const modelList = models
									.map((m) => {
										const current = m.name === currentModelId ? " **[CURRENT]**" : "";
										const size = formatModelSize(m.size);
										const family = m.details?.family ? ` (${m.details.family})` : "";
										return `‚Ä¢ \`${m.name}\`${family} - ${size}${current}`;
									})
									.join("\n");

								const embed = new EmbedBuilder()
									.setColor(0x0099FF)
									.setTitle("Available Ollama Models")
									.setDescription(modelList)
									.addFields(
										{ name: "Current Model", value: `\`${currentModelId}\``, inline: true },
										{ name: "Total Models", value: String(models.length), inline: true }
									)
									.setFooter({ text: "Use /model switch <name> to change models" })
									.setTimestamp();

								await interaction.editReply({ embeds: [embed] });
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.editReply(`Error fetching models: ${errMsg}`);
							}
							break;
						}

						case "switch": {
							const modelName = interaction.options.getString("name", true);
							const isGlobal = interaction.options.getBoolean("global") || false;

							// Only admin can set global model
							if (isGlobal && !isOwner(user.id)) {
								await interaction.reply({ content: "Only the bot owner can set the global model.", ephemeral: true });
								break;
							}

							await interaction.deferReply();

							try {
								// Verify model exists
								const models = await fetchOllamaModels();
								const modelExists = models.some((m) => m.name === modelName);

								if (!modelExists) {
									await interaction.editReply(
										`Model \`${modelName}\` not found. Use \`/model list\` to see available models.\n\n` +
										`To download a new model, run: \`ollama pull ${modelName}\``
									);
									break;
								}

								// Switch model
								if (isGlobal) {
									setGlobalModel(modelName);
									logAdminAction(user.id, user.username, "set_global_model", modelName);
									await interaction.editReply(`Global model set to \`${modelName}\` for all users.`);
								} else {
									setUserModel(user.id, modelName);
									await interaction.editReply(`Your model has been switched to \`${modelName}\`.`);
								}
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.editReply(`Error switching model: ${errMsg}`);
							}
							break;
						}

						case "info": {
							await interaction.deferReply();

							try {
								const currentModelId = getCurrentModelId(user.id);
								const models = await fetchOllamaModels();
								const currentModel = models.find((m) => m.name === currentModelId);

								const embed = new EmbedBuilder()
									.setColor(0x0099FF)
									.setTitle("Current Model Information")
									.addFields(
										{ name: "Model Name", value: `\`${currentModelId}\``, inline: true },
										{ name: "Is Personal", value: userModels.has(user.id) ? "Yes" : "No (using global)", inline: true }
									);

								if (currentModel) {
									embed.addFields(
										{ name: "Size", value: formatModelSize(currentModel.size), inline: true },
										{ name: "Family", value: currentModel.details?.family || "Unknown", inline: true },
										{ name: "Parameter Size", value: currentModel.details?.parameter_size || "Unknown", inline: true },
										{ name: "Last Modified", value: new Date(currentModel.modified_at).toLocaleDateString(), inline: true }
									);
								}

								embed.setFooter({ text: "Use /model switch to change models" })
									.setTimestamp();

								await interaction.editReply({ embeds: [embed] });
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.editReply(`Error fetching model info: ${errMsg}`);
							}
							break;
						}
					}
					break;
				}

				case "provider": {
					const subCommand = interaction.options.getSubcommand();

					switch (subCommand) {
						case "status": {
							const providerInfo = currentProvider === "openrouter"
								? `**OpenRouter** (Cloud)\n- Model: ${OPENROUTER_MODELS[globalModelId]?.name || globalModelId}\n- Cost: ${OPENROUTER_MODELS[globalModelId]?.cost || "varies"}`
								: `**Ollama** (Local)\n- Model: ${globalModelId}\n- Cost: FREE (runs locally)`;

							const embed = new EmbedBuilder()
								.setColor(currentProvider === "openrouter" ? 0x7C3AED : 0x00FF00)
								.setTitle("üîå AI Provider Status")
								.setDescription(`Current provider: ${providerInfo}`)
								.addFields(
									{ name: "Available Providers", value: "‚Ä¢ `/provider ollama` - Free, private, local\n‚Ä¢ `/provider openrouter` - Fast, cheap, cloud", inline: false },
									{ name: "OpenRouter API Key", value: OPENROUTER_API_KEY ? "‚úÖ Configured" : "‚ùå Not set", inline: true }
								)
								.setFooter({ text: "Use /provider ollama or /provider openrouter to switch" });

							await interaction.reply({ embeds: [embed] });
							break;
						}

						case "ollama": {
							currentProvider = "ollama";
							globalModelId = DEFAULT_MODEL_ID;
							// Clear all channel states so agents get recreated with new provider
							channelStates.clear();
							logInfo(`Switched to Ollama provider with model: ${globalModelId}`);

							await interaction.reply({
								content: `‚úÖ Switched to **Ollama** (local, free)\n- Model: \`${globalModelId}\`\n- All processing stays on your server`,
								ephemeral: false
							});
							break;
						}

						case "openrouter": {
							if (!OPENROUTER_API_KEY) {
								await interaction.reply({
									content: "‚ùå OpenRouter API key not configured. Set `OPENROUTER_API_KEY` environment variable.",
									ephemeral: true
								});
								break;
							}

							const modelChoice = interaction.options.getString("model") || DEFAULT_OPENROUTER_MODEL;
							currentProvider = "openrouter";
							globalModelId = modelChoice;
							// Clear all channel states so agents get recreated with new provider
							channelStates.clear();

							const modelInfo = OPENROUTER_MODELS[modelChoice];
							logInfo(`Switched to OpenRouter provider with model: ${modelInfo?.id || modelChoice}`);

							await interaction.reply({
								content: `‚úÖ Switched to **OpenRouter** (cloud)\n- Model: \`${modelInfo?.name || modelChoice}\`\n- Cost: ${modelInfo?.cost || "varies"}\n- 100% accuracy on financial sentiment!`,
								ephemeral: false
							});
							break;
						}
					}
					break;
				}

				case "analytics": {
					const period = (interaction.options.getString("period") as "today" | "week" | "all") || "today";
					await interaction.deferReply();

					try {
						const stats = analytics.getStats(period);
						const hourlyDist = analytics.getHourlyDistribution();

						// Build hourly chart (simple text-based)
						const peakHour = Object.entries(hourlyDist).reduce((max, [h, count]) => {
							return count > max.count ? { hour: parseInt(h), count } : max;
						}, { hour: 0, count: 0 });

						// Create embed
						const periodName = period === "today" ? "Today" : period === "week" ? "This Week" : "All Time";
						const embed = new EmbedBuilder()
							.setColor(0x00FF00)
							.setTitle(`üìä Analytics - ${periodName}`)
							.addFields(
								{ name: "Total Commands", value: String(stats.totalCommands), inline: true },
								{ name: "Unique Users", value: String(stats.uniqueUsers), inline: true },
								{ name: "Errors", value: String(stats.errors), inline: true },
								{ name: "Avg Response Time", value: `${stats.avgResponseTime.toFixed(0)}ms`, inline: true },
								{ name: "Peak Hour", value: period === "today" ? `${peakHour.hour}:00 (${peakHour.count} cmds)` : "N/A", inline: true },
								{ name: "Error Rate", value: stats.totalCommands > 0 ? `${((stats.errors / stats.totalCommands) * 100).toFixed(1)}%` : "0%", inline: true }
							);

						// Top commands
						if (stats.topCommands.length > 0) {
							const topCmdsText = stats.topCommands
								.map((c, i) => `${i + 1}. \`${c.command}\` - ${c.count} uses`)
								.join("\n");
							embed.addFields({ name: "Top Commands", value: topCmdsText, inline: false });
						}

						// Active users (limit to 5 for display)
						if (stats.activeUsers.length > 0) {
							const activeUsersText = stats.activeUsers
								.slice(0, 5)
								.map((u, i) => `${i + 1}. ${u.username} - ${u.count} commands`)
								.join("\n");
							embed.addFields({ name: "Most Active Users", value: activeUsersText, inline: false });
						}

						embed.setTimestamp().setFooter({ text: "Analytics powered by pi-discord" });

						await interaction.editReply({ embeds: [embed] });
					} catch (error) {
						const errMsg = error instanceof Error ? error.message : String(error);
						await interaction.editReply(`Error fetching analytics: ${errMsg}`);
					}
					break;
				}

				case "admin": {
					// Admin-only commands - check owner permission
					if (!isOwner(user.id)) {
						await interaction.reply({ content: "Permission denied. This command is owner-only.", ephemeral: true });
						logWarning(`Unauthorized admin command attempt by ${user.username}`, user.id);
						return;
					}

					const subcommand = interaction.options.getSubcommand();

					switch (subcommand) {
						case "stats": {
							await interaction.deferReply({ ephemeral: true });

							const uptime = Date.now() - botStats.startTime;
							const hours = Math.floor(uptime / (1000 * 60 * 60));
							const mins = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
							const uptimeStr = `${hours}h ${mins}m`;

							const memUsage = process.memoryUsage();
							const memoryStr = `${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB / ${(memUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`;

							const embed = new EmbedBuilder()
								.setColor(0x00FF00)
								.setTitle("Admin - Bot Statistics")
								.addFields(
									{ name: "Uptime", value: uptimeStr, inline: true },
									{ name: "Commands Processed", value: String(botStats.commandsProcessed), inline: true },
									{ name: "Messages Processed", value: String(botStats.messagesProcessed), inline: true },
									{ name: "Errors Count", value: String(botStats.errorsCount), inline: true },
									{ name: "Active Channels", value: String(channelStates.size), inline: true },
									{ name: "Unique Users", value: String(botStats.userInteractions.size), inline: true },
									{ name: "Memory Usage", value: memoryStr, inline: false },
									{ name: "Model", value: `\`${model.id}\``, inline: true },
									{ name: "Working Directory", value: `\`${workingDir}\``, inline: false }
								)
								.setTimestamp()
								.setFooter({ text: "Admin Panel" });

							await interaction.editReply({ embeds: [embed] });
							logAdminAction(user.id, user.username, "stats");
							break;
						}

						case "users": {
							await interaction.deferReply({ ephemeral: true });

							const users = Array.from(botStats.userInteractions.values())
								.sort((a, b) => b.count - a.count)
								.slice(0, 20)
								.map((u, i) => {
									const lastSeenDate = new Date(u.lastSeen);
									const timeDiff = Date.now() - u.lastSeen;
									const hoursAgo = Math.floor(timeDiff / (1000 * 60 * 60));
									const minsAgo = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
									const timeAgo = hoursAgo > 0 ? `${hoursAgo}h ago` : `${minsAgo}m ago`;

									return `${i + 1}. **${u.username}** - ${u.count} interactions (${timeAgo})`;
								})
								.join("\n");

							const embed = new EmbedBuilder()
								.setColor(0x0099FF)
								.setTitle("Admin - User Statistics")
								.setDescription(users || "No users yet")
								.addFields(
									{ name: "Total Unique Users", value: String(botStats.userInteractions.size), inline: true }
								)
								.setTimestamp()
								.setFooter({ text: "Top 20 users by interaction count" });

							await interaction.editReply({ embeds: [embed] });
							logAdminAction(user.id, user.username, "users");
							break;
						}

						case "broadcast": {
							const message = interaction.options.getString("message", true);
							await interaction.deferReply({ ephemeral: true });

							let successCount = 0;
							let failCount = 0;

							for (const [guildId, guild] of client.guilds.cache) {
								try {
									const textChannels = guild.channels.cache.filter(
										(ch) => ch.isTextBased() && ch.type === 0
									);

									if (textChannels.size > 0) {
										const firstChannel = textChannels.first() as TextChannel;
										await firstChannel.send(`**Broadcast from Bot Owner:**\n${message}`);
										successCount++;
									}
								} catch (error) {
									failCount++;
									logError(`Broadcast failed for guild ${guild.name}`, error instanceof Error ? error.message : String(error));
								}
							}

							await interaction.editReply(`Broadcast sent to ${successCount} server(s). Failed: ${failCount}`);
							logAdminAction(user.id, user.username, "broadcast", `Sent to ${successCount} servers`);
							break;
						}

						case "reload": {
							await interaction.deferReply({ ephemeral: true });

							try {
								// Reload skills for all active channels
								let reloadCount = 0;
								for (const [channelId, state] of channelStates) {
									const channelDir = join(workingDir, channelId);
									const memory = getMemory(channelDir, workingDir);
									const channelNameTemp = channelId; // We don't have channel name here
									const systemPrompt = buildSystemPrompt(workingDir, channelId, channelNameTemp, memory);
									state.agent.setSystemPrompt(systemPrompt);
									reloadCount++;
								}

								await interaction.editReply(`Skills reloaded successfully for ${reloadCount} active channel(s).`);
								logAdminAction(user.id, user.username, "reload", `Reloaded ${reloadCount} channels`);
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.editReply(`Error reloading skills: ${errMsg}`);
							}
							break;
						}

						case "config": {
							const key = interaction.options.getString("key", true);
							const value = interaction.options.getString("value");

							if (!value) {
								// View configuration
								const currentValue = runtimeConfig[key];
								await interaction.reply({
									content: currentValue !== undefined
										? `**${key}** = \`${currentValue}\``
										: `Configuration key "${key}" not found.\n\nAvailable keys:\n${Object.keys(runtimeConfig).map(k => `- ${k}`).join("\n")}`,
									ephemeral: true
								});
								logAdminAction(user.id, user.username, "config view", key);
							} else {
								// Set configuration
								let parsedValue: string | number | boolean = value;

								// Try to parse as number or boolean
								if (value === "true") parsedValue = true;
								else if (value === "false") parsedValue = false;
								else if (!isNaN(Number(value))) parsedValue = Number(value);

								runtimeConfig[key] = parsedValue;

								await interaction.reply({
									content: `Configuration updated: **${key}** = \`${parsedValue}\``,
									ephemeral: true
								});
								logAdminAction(user.id, user.username, "config set", `${key} = ${parsedValue}`);
							}
							break;
						}

						case "logs": {
							const lines = interaction.options.getInteger("lines") || 50;
							await interaction.deferReply({ ephemeral: true });

							try {
								// Try to read bot logs
								const logSources = [
									"/var/log/discord-bot.log",
									"/opt/discord-bot-data/bot.log",
									"/var/log/syslog"
								];

								let logs = "";
								for (const logPath of logSources) {
									try {
										const result = await execCommand(`tail -n ${lines} ${shellEscape(logPath)} 2>/dev/null | grep -i discord || echo ""`);
										if (result.stdout.trim()) {
											logs = result.stdout;
											break;
										}
									} catch {}
								}

								if (!logs) {
									logs = "No logs found. Showing process info:\n";
									const psResult = await execCommand(`ps aux | grep discord | grep -v grep`);
									logs += psResult.stdout || "No process info available";
								}

								// Truncate if too long
								if (logs.length > 1900) {
									logs = logs.substring(logs.length - 1900);
								}

								await interaction.editReply(`**Recent Logs:**\n\`\`\`\n${logs}\n\`\`\``);
								logAdminAction(user.id, user.username, "logs", `Viewed ${lines} lines`);
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.editReply(`Error fetching logs: ${errMsg}`);
							}
							break;
						}

						case "restart": {
							await interaction.reply({ content: "Initiating graceful restart...", ephemeral: true });
							logAdminAction(user.id, user.username, "restart", "Restarting bot");

							try {
								// Try systemd restart
								const result = await execCommand("systemctl restart discord-bot 2>&1 || systemctl restart pi-discord 2>&1 || echo 'Systemd service not found'");

								if (result.stdout.includes("not found")) {
									// Fallback: exit process and let Docker/PM2 restart it
									await interaction.followUp({ content: "Systemd service not found. Exiting process (should auto-restart)...", ephemeral: true });
									setTimeout(() => process.exit(0), 2000);
								} else {
									await interaction.followUp({ content: "Restart command sent to systemd.", ephemeral: true });
								}
							} catch (error) {
								const errMsg = error instanceof Error ? error.message : String(error);
								await interaction.followUp({ content: `Error during restart: ${errMsg}`, ephemeral: true });
							}
							break;
						}
					}
					break;
				}

				case "tools": {
					const category = interaction.options.getString("category") || "all";

					const toolsInfo = {
						web: [
							{ name: "web_search", desc: "Search the web using Exa AI", usage: "search the web for..." },
							{ name: "free_search", desc: "Free DuckDuckGo search (no API key)", usage: "quick search for..." },
							{ name: "deep_research", desc: "AI-powered deep research on complex topics", usage: "research..." },
							{ name: "web_scrape", desc: "Scrape web pages with anti-bot bypass", usage: "scrape URL..." },
						],
						github: [
							{ name: "github_search", desc: "Search GitHub repositories", usage: "search github for..." },
							{ name: "github_file", desc: "Get file contents from GitHub", usage: "show file from repo..." },
							{ name: "github_issues", desc: "List issues from a repository", usage: "list issues for..." },
							{ name: "github_create_issue", desc: "Create new GitHub issue", usage: "create issue..." },
							{ name: "github_branch", desc: "Create new branch", usage: "create branch..." },
							{ name: "github_pr", desc: "Create pull request", usage: "create PR..." },
							{ name: "github_list_prs", desc: "List pull requests", usage: "list PRs for..." },
						],
						hf: [
							{ name: "hf_models", desc: "Search HuggingFace models", usage: "find HF models for..." },
							{ name: "hf_datasets", desc: "Search HuggingFace datasets", usage: "find datasets for..." },
						],
						memory: [
							{ name: "memory_store", desc: "Store info in knowledge graph", usage: "remember that..." },
							{ name: "memory_recall", desc: "Recall from knowledge graph", usage: "what do you know about..." },
							{ name: "memory_relate", desc: "Create entity relationships", usage: "X is related to Y..." },
						],
						tasks: [
							{ name: "task_create", desc: "Create task with dependencies", usage: "create task to..." },
							{ name: "task_list", desc: "List tasks by status", usage: "show pending tasks..." },
							{ name: "task_update", desc: "Update task status/progress", usage: "mark task X done..." },
						],
						codebase: [
							{ name: "codebase_knowledge", desc: "Search pi-mono docs & knowledge", usage: "how does pi-ai work..." },
							{ name: "pimono_read", desc: "Read pi-mono source files", usage: "show packages/ai/src/index.ts" },
							{ name: "pimono_list", desc: "List pi-mono directories", usage: "list packages/" },
						],
						skills: [
							{ name: "skill_list", desc: "List all available skills (SKILL.md files)", usage: "what skills are available..." },
							{ name: "skill_load", desc: "Load skill instructions for a domain", usage: "load the trading skill..." },
							{ name: "skill_create", desc: "Create new skill from learned knowledge", usage: "create a skill about..." },
						],
						self: [
							{ name: "memory_update", desc: "Update bot's persistent MEMORY.md", usage: "remember that user prefers..." },
							{ name: "skill_create", desc: "Create reusable skill files", usage: "create skill for..." },
							{ name: "context_compact", desc: "Summarize old messages to reduce context", usage: "compact context..." },
						],
						agents: [
							{ name: "agent_spawn", desc: "Spawn sub-agent for parallel tasks", usage: "spawn agent to research..." },
							{ name: "agent_delegate", desc: "Delegate multiple tasks to agents", usage: "delegate these tasks..." },
						],
						hooks: [
							{ name: "hooks_list", desc: "List lifecycle hooks", usage: "list hooks..." },
							{ name: "hook_create", desc: "Create new hook", usage: "create hook for..." },
						],
						audio: [
							{ name: "transcribe", desc: "Transcribe audio to text (Groq Whisper)", usage: "transcribe this audio..." },
						],
						rag: [
							{ name: "knowledge_search", desc: "Search knowledge base & skills (RAG)", usage: "search knowledge for..." },
						],
						vision: [
							{ name: "image_analyze", desc: "Analyze images with AI vision (OCR, describe)", usage: "analyze this image..." },
						],
						code: [
							{ name: "code_sandbox", desc: "Execute code safely (Python/JS/TS/Bash)", usage: "run this python code..." },
						],
						scheduled: [
							{ name: "schedule_task", desc: "Create scheduled/cron tasks", usage: "schedule daily message..." },
							{ name: "scheduled_tasks_list", desc: "List all scheduled tasks", usage: "show scheduled tasks..." },
						],
						learning: [
							{ name: "auto_learn", desc: "Extract learnings from conversations", usage: "learn from this chat..." },
						],
						files: [
							{ name: "file_process", desc: "Process uploaded files (images, code, text)", usage: "analyze this file..." },
						],
						embeds: [
							{ name: "rich_embed", desc: "Create beautiful Discord embeds", usage: "show as embed..." },
						],
						docker: [
							{ name: "docker_sandbox", desc: "Execute code in isolated Docker container", usage: "run in docker..." },
						],
						export: [
							{ name: "conversation_export", desc: "Export chat history (markdown/JSON)", usage: "export this conversation..." },
						],
						prefs: [
							{ name: "user_preferences", desc: "Get/set user preferences", usage: "remember I prefer..." },
						],
						voice: [
							{ name: "voice_join", desc: "Join a voice channel", usage: "join voice channel..." },
							{ name: "voice_tts", desc: "Text-to-speech in voice channel", usage: "say this in voice..." },
						],
						plugins: [
							{ name: "plugin_load", desc: "Load external plugin", usage: "load plugin..." },
							{ name: "plugin_list", desc: "List registered plugins", usage: "show plugins..." },
						],
						commands: [
							{ name: "slash_command_create", desc: "Create custom slash command", usage: "create /mycommand..." },
							{ name: "slash_command_list", desc: "List custom commands", usage: "show custom commands..." },
						],
						servers: [
							{ name: "server_sync", desc: "Sync knowledge between servers", usage: "sync from server X to Y..." },
							{ name: "server_list", desc: "List servers with bot data", usage: "show all servers..." },
						],
					};

					let response = "";
					const categories = category === "all" ? Object.keys(toolsInfo) : [category];

					for (const cat of categories) {
						const tools = toolsInfo[cat as keyof typeof toolsInfo];
						if (!tools) continue;

						const catNames: Record<string, string> = {
							web: "Web & Search",
							github: "GitHub",
							hf: "HuggingFace",
							memory: "Memory",
							tasks: "Tasks",
							codebase: "Codebase Knowledge",
							skills: "Skills System",
							self: "Self-Management",
							agents: "Multi-Agent",
							hooks: "Hooks System",
							audio: "Audio/Voice",
							rag: "Knowledge Base (RAG)",
							vision: "Vision/Image Analysis",
							code: "Code Execution",
							scheduled: "Scheduled Tasks",
							learning: "Auto-Learning",
							files: "File Processing",
							embeds: "Rich Embeds",
							docker: "Docker Sandbox",
							export: "Conversation Export",
							prefs: "User Preferences",
							voice: "Voice Channel",
							plugins: "Plugin System",
							commands: "Custom Commands",
							servers: "Multi-Server",
						};

						response += `\n**${catNames[cat] || cat}**\n`;
						for (const tool of tools) {
							response += `\`${tool.name}\` - ${tool.desc}\n`;
						}
					}

					const embed = new EmbedBuilder()
						.setColor(0x0099FF)
						.setTitle("Available MCP Tools")
						.setDescription(response.trim())
						.addFields(
							{ name: "Usage", value: "Just ask naturally! The bot auto-detects when to use tools.", inline: false },
							{ name: "Examples", value: "`search github for ai agent`\n`find HF models for image generation`\n`research quantum computing`", inline: false }
						)
						.setTimestamp()
						.setFooter({ text: `${Object.values(toolsInfo).flat().length} tools available` });

					await interaction.reply({ embeds: [embed] });
					break;
				}

				case "generate": {
					const subcommand = interaction.options.getSubcommand();
					await interaction.deferReply();

					try {
						switch (subcommand) {
							case "image": {
								const prompt = interaction.options.getString("prompt", true);
								const model = interaction.options.getString("model") || "flux-dev";

								const FAL_KEY = process.env.FAL_KEY;
								if (!FAL_KEY) {
									await interaction.editReply("‚ùå FAL_KEY not configured.");
									break;
								}

								const modelMap: Record<string, string> = {
									"flux-dev": "fal-ai/flux/dev",
									"flux-schnell": "fal-ai/flux/schnell",
									"flux-pro": "fal-ai/flux-pro/v1.1",
									"flux-realism": "fal-ai/flux-realism",
									"ideogram": "fal-ai/ideogram/v2",
									"recraft": "fal-ai/recraft-v3",
								};

								const response = await fetch(`https://queue.fal.run/${modelMap[model] || modelMap["flux-dev"]}`, {
									method: "POST",
									headers: { "Authorization": `Key ${FAL_KEY}`, "Content-Type": "application/json" },
									body: JSON.stringify({ prompt, image_size: "landscape_16_9", num_inference_steps: 28 }),
								});

								const result = await response.json() as { images?: Array<{ url: string }> };
								if (result.images?.[0]?.url) {
									const embed = new EmbedBuilder()
										.setColor(0x7C3AED)
										.setTitle("üé® Image Generated")
										.setDescription(`**Prompt:** ${prompt.slice(0, 200)}`)
										.setImage(result.images[0].url)
										.setFooter({ text: `Model: ${model}` });
									await interaction.editReply({ embeds: [embed] });
								} else {
									await interaction.editReply(`Image generation failed: ${JSON.stringify(result).slice(0, 500)}`);
								}
								break;
							}

							case "music": {
								const prompt = interaction.options.getString("prompt", true);
								const style = interaction.options.getString("style") || "";

								const SUNO_KEY = process.env.SUNO_API_KEY;
								if (!SUNO_KEY) {
									await interaction.editReply("‚ùå SUNO_API_KEY not configured.");
									break;
								}

								const fullPrompt = style ? `${style}: ${prompt}` : prompt;
								await interaction.editReply(`üéµ Generating music for: "${fullPrompt.slice(0, 100)}..."\n\n‚è≥ This may take 1-2 minutes...`);

								// Music generation is async, provide status
								const embed = new EmbedBuilder()
									.setColor(0xFF6B6B)
									.setTitle("üéµ Music Generation Started")
									.setDescription(`**Prompt:** ${fullPrompt.slice(0, 200)}\n\nUse \`@bot check music status\` to see progress.`)
									.setFooter({ text: "Powered by Suno AI" });
								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "video": {
								const prompt = interaction.options.getString("prompt", true);
								const imageUrl = interaction.options.getString("image_url");

								const FAL_KEY = process.env.FAL_KEY;
								if (!FAL_KEY) {
									await interaction.editReply("‚ùå FAL_KEY not configured.");
									break;
								}

								await interaction.editReply(`üé¨ Generating video for: "${prompt.slice(0, 100)}..."\n\n‚è≥ This may take 2-5 minutes...`);
								break;
							}

							case "voice": {
								const text = interaction.options.getString("text", true);
								const engine = interaction.options.getString("engine") || "vibevoice";

								const embed = new EmbedBuilder()
									.setColor(0x00D4AA)
									.setTitle("üó£Ô∏è Voice Generation")
									.setDescription(`**Text:** ${text.slice(0, 200)}...\n**Engine:** ${engine}\n\nUse \`@bot generate voice: ${text.slice(0, 50)}...\` for full generation.`)
									.setFooter({ text: "TTS Generation" });
								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "3d": {
								const prompt = interaction.options.getString("prompt", true);
								const imageUrl = interaction.options.getString("image_url");

								const embed = new EmbedBuilder()
									.setColor(0x9B59B6)
									.setTitle("üéÆ 3D Model Generation")
									.setDescription(`**Prompt:** ${prompt.slice(0, 200)}\n${imageUrl ? `**Image:** ${imageUrl}` : ""}\n\nUse \`@bot create 3d model: ${prompt.slice(0, 50)}...\` for full generation.`)
									.setFooter({ text: imageUrl ? "Image to 3D (TripoSR)" : "Text to 3D (Shap-E)" });
								await interaction.editReply({ embeds: [embed] });
								break;
							}
						}
					} catch (error) {
						await interaction.editReply(`‚ùå Generation error: ${error instanceof Error ? error.message : String(error)}`);
					}
					break;
				}

				case "livekit": {
					const subcommand = interaction.options.getSubcommand();
					await interaction.deferReply();

					const LIVEKIT_URL = process.env.LIVEKIT_URL;
					const LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY;
					const LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET;

					if (!LIVEKIT_URL || !LIVEKIT_API_KEY || !LIVEKIT_API_SECRET) {
						await interaction.editReply("‚ùå LiveKit not configured. Set LIVEKIT_URL, LIVEKIT_API_KEY, LIVEKIT_API_SECRET");
						break;
					}

					try {
						switch (subcommand) {
							case "create": {
								const roomName = interaction.options.getString("name", true);
								const embed = new EmbedBuilder()
									.setColor(0x00D4AA)
									.setTitle("üéôÔ∏è LiveKit Room")
									.setDescription(`Room **${roomName}** created!\n\nUse \`/livekit join ${roomName}\` to get a join token.`)
									.setFooter({ text: LIVEKIT_URL });
								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "join": {
								const roomName = interaction.options.getString("room", true);
								const embed = new EmbedBuilder()
									.setColor(0x00D4AA)
									.setTitle("üé´ Join Token")
									.setDescription(`**Room:** ${roomName}\n\nUse \`@bot create livekit token for ${roomName}\` to generate a join token.`)
									.setFooter({ text: LIVEKIT_URL });
								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "list": {
								const embed = new EmbedBuilder()
									.setColor(0x00D4AA)
									.setTitle("üéôÔ∏è Active Rooms")
									.setDescription("Use `@bot list livekit rooms` to see active rooms.")
									.setFooter({ text: LIVEKIT_URL });
								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "record": {
								const roomName = interaction.options.getString("room", true);
								const action = interaction.options.getString("action", true);
								const embed = new EmbedBuilder()
									.setColor(action === "start" ? 0xFF0000 : 0x00FF00)
									.setTitle(action === "start" ? "üî¥ Recording Started" : "‚èπÔ∏è Recording Stopped")
									.setDescription(`**Room:** ${roomName}`)
									.setFooter({ text: LIVEKIT_URL });
								await interaction.editReply({ embeds: [embed] });
								break;
							}
						}
					} catch (error) {
						await interaction.editReply(`‚ùå LiveKit error: ${error instanceof Error ? error.message : String(error)}`);
					}
					break;
				}

				case "schedule": {
					await interaction.deferReply();
					const subcommand = interaction.options.getSubcommand();
					const userId = interaction.user.id;

					try {
						switch (subcommand) {
							case "add": {
								const name = interaction.options.getString("name", true);
								const cronExpr = interaction.options.getString("cron", true);
								const action = interaction.options.getString("action", true);
								const channel = interaction.options.getChannel("channel");
								const channelId = channel?.id || interaction.channelId;

								// Validate cron expression
								if (!taskScheduler.constructor.validateCron(cronExpr)) {
									await interaction.editReply("‚ùå Invalid cron expression. Example: `0 9 * * *` for 9 AM daily");
									break;
								}

								// Add task
								const task = taskScheduler.addTask({
									name,
									cron: cronExpr,
									action,
									channelId,
									userId,
									enabled: true
								});

								const cronDesc = taskScheduler.constructor.describeCron(cronExpr);
								const embed = new EmbedBuilder()
									.setColor(0x00FF00)
									.setTitle("‚úÖ Scheduled Task Created")
									.setDescription(`**${name}**\n${cronDesc}`)
									.addFields(
										{ name: "Task ID", value: task.id, inline: true },
										{ name: "Action", value: action, inline: true },
										{ name: "Channel", value: `<#${channelId}>`, inline: true }
									)
									.setTimestamp()
									.setFooter({ text: "Task is now active" });

								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "list": {
								const tasks = taskScheduler.listTasks(userId);

								if (tasks.length === 0) {
									await interaction.editReply("You don't have any scheduled tasks. Use `/schedule add` to create one!");
									break;
								}

								const taskList = tasks.map(task => {
									const status = task.enabled ? "üü¢ Enabled" : "üî¥ Disabled";
									const lastRun = task.lastRun ? `Last: ${new Date(task.lastRun).toLocaleString()}` : "Never run";
									return `**${task.name}** (${task.id})\n${status} ‚Ä¢ ${task.cron} ‚Ä¢ ${lastRun}\nAction: ${task.action}`;
								}).join("\n\n");

								const embed = new EmbedBuilder()
									.setColor(0x0099FF)
									.setTitle("üìÖ Your Scheduled Tasks")
									.setDescription(taskList.substring(0, 4000))
									.setTimestamp()
									.setFooter({ text: `Total: ${tasks.length} task(s)` });

								await interaction.editReply({ embeds: [embed] });
								break;
							}

							case "remove": {
								const taskId = interaction.options.getString("id", true);
								const success = taskScheduler.removeTask(taskId);

								if (success) {
									await interaction.editReply(`‚úÖ Task **${taskId}** has been removed.`);
								} else {
									await interaction.editReply("‚ùå Task not found or you don't have permission to remove it.");
								}
								break;
							}

							case "toggle": {
								const taskId = interaction.options.getString("id", true);
								const task = taskScheduler.toggleTask(taskId);

								if (task) {
									const status = task.enabled ? "enabled" : "disabled";
									const emoji = task.enabled ? "‚úÖ" : "‚è∏Ô∏è";
									await interaction.editReply(`${emoji} Task **${task.name}** is now **${status}**.`);
								} else {
									await interaction.editReply("‚ùå Task not found or you don't have permission to modify it.");
								}
								break;
							}

							case "info": {
								const taskId = interaction.options.getString("id", true);
								const task = taskScheduler.getTask(taskId);

								if (!task) {
									await interaction.editReply("‚ùå Task not found.");
									break;
								}

								const cronDesc = taskScheduler.constructor.describeCron(task.cron);
								const embed = new EmbedBuilder()
									.setColor(task.enabled ? 0x00FF00 : 0xFF0000)
									.setTitle(`üìã Task: ${task.name}`)
									.addFields(
										{ name: "ID", value: task.id, inline: true },
										{ name: "Status", value: task.enabled ? "üü¢ Enabled" : "üî¥ Disabled", inline: true },
										{ name: "Channel", value: `<#${task.channelId}>`, inline: true },
										{ name: "Cron Expression", value: task.cron, inline: true },
										{ name: "Schedule", value: cronDesc, inline: true },
										{ name: "Action", value: task.action },
										{ name: "Created", value: new Date(task.createdAt).toLocaleString(), inline: true },
										{ name: "Last Run", value: task.lastRun ? new Date(task.lastRun).toLocaleString() : "Never", inline: true }
									)
									.setTimestamp();

								await interaction.editReply({ embeds: [embed] });
								break;
							}
						}
					} catch (error) {
						await interaction.editReply(`‚ùå Error: ${error instanceof Error ? error.message : String(error)}`);
					}
					break;
				}

				case "health": {
					await interaction.deferReply();

					const checks: Array<{ name: string; status: string; latency?: number }> = [];

					// Bot uptime
					const uptime = Date.now() - botStats.startTime;
					const hours = Math.floor(uptime / (1000 * 60 * 60));
					const mins = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
					checks.push({ name: "Bot Uptime", status: `${hours}h ${mins}m` });

					// Memory
					const memUsage = process.memoryUsage();
					checks.push({ name: "Memory", status: `${(memUsage.heapUsed / 1024 / 1024).toFixed(1)} MB` });

					// OpenRouter API
					if (process.env.OPENROUTER_API_KEY) {
						try {
							const start = Date.now();
							const resp = await fetch("https://openrouter.ai/api/v1/models", {
								headers: { "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}` }
							});
							checks.push({ name: "OpenRouter API", status: resp.ok ? "‚úÖ OK" : "‚ùå Error", latency: Date.now() - start });
						} catch {
							checks.push({ name: "OpenRouter API", status: "‚ùå Unreachable" });
						}
					}

					// Fal.ai API
					if (process.env.FAL_KEY) {
						checks.push({ name: "Fal.ai (Images)", status: "‚úÖ Configured" });
					} else {
						checks.push({ name: "Fal.ai (Images)", status: "‚ö†Ô∏è Not configured" });
					}

					// Suno API
					if (process.env.SUNO_API_KEY) {
						checks.push({ name: "Suno (Music)", status: "‚úÖ Configured" });
					} else {
						checks.push({ name: "Suno (Music)", status: "‚ö†Ô∏è Not configured" });
					}

					// LiveKit
					if (process.env.LIVEKIT_URL) {
						checks.push({ name: "LiveKit (Voice)", status: "‚úÖ Configured" });
					} else {
						checks.push({ name: "LiveKit (Voice)", status: "‚ö†Ô∏è Not configured" });
					}

					// ElevenLabs
					if (process.env.ELEVENLABS_API_KEY) {
						checks.push({ name: "ElevenLabs (TTS)", status: "‚úÖ Configured" });
					} else {
						checks.push({ name: "ElevenLabs (TTS)", status: "‚ö†Ô∏è Not configured" });
					}

					const embed = new EmbedBuilder()
						.setColor(0x00FF00)
						.setTitle("üè• Bot Health Status")
						.setDescription(checks.map(c =>
							`**${c.name}:** ${c.status}${c.latency ? ` (${c.latency}ms)` : ""}`
						).join("\n"))
						.addFields(
							{ name: "Commands Processed", value: String(botStats.commandsProcessed), inline: true },
							{ name: "Active Channels", value: String(channelStates.size), inline: true },
							{ name: "Total Tools", value: "89", inline: true }
						)
						.setTimestamp()
						.setFooter({ text: "Pi-Agent Health Check" });

					await interaction.editReply({ embeds: [embed] });
					break;
				}

				case "reset": {
					const channelDir = join(workingDir, channelId);
					const state = channelStates.get(channelId);

					// Clear agent messages if state exists
					if (state?.agent) {
						state.agent.reset();
					}

					// Clear session file
					clearSession(channelDir);

					// Remove channel state so it gets recreated fresh
					channelStates.delete(channelId);

					await interaction.reply({
						content: "üîÑ **Conversation Reset**\nHistory cleared for this channel. I'm starting fresh!",
						ephemeral: false
					});

					logInfo(`[RESET] Channel ${channelId} history cleared by ${user.username}`);
					break;
				}

				case "backup": {
					await interaction.deferReply({ ephemeral: true });

					const scope = interaction.options.getString("scope") || "channel";
					const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
					const backupDir = join(workingDir, "backups");

					if (!existsSync(backupDir)) {
						mkdirSync(backupDir, { recursive: true });
					}

					try {
						if (scope === "channel") {
							const channelDir = join(workingDir, channelId);
							if (!existsSync(channelDir)) {
								await interaction.editReply("‚ùå No data to backup for this channel.");
								break;
							}

							const backupPath = join(backupDir, `channel-${channelId}-${timestamp}.tar.gz`);

							// Create tarball of channel data
							const { execSync } = await import("child_process");
							execSync(`tar -czf "${backupPath}" -C "${workingDir}" "${channelId}"`);

							const stats = await import("fs").then(fs => fs.statSync(backupPath));
							const sizeMB = (stats.size / 1024 / 1024).toFixed(2);

							await interaction.editReply({
								content: `‚úÖ **Channel Backup Created**\nüìÅ \`${backupPath}\`\nüìä Size: ${sizeMB} MB\n\nRetrieve with: \`scp user@server:${backupPath} ./\``
							});

							logInfo(`[BACKUP] Channel ${channelId} backed up by ${user.username} (${sizeMB} MB)`);
						} else {
							// Backup all data
							const backupPath = join(backupDir, `full-backup-${timestamp}.tar.gz`);

							const { execSync } = await import("child_process");
							// Exclude the backups directory itself to avoid recursion
							execSync(`tar --exclude='backups' -czf "${backupPath}" -C "${resolve(workingDir, "..")}" "${workingDir.split("/").pop()}"`);

							const stats = await import("fs").then(fs => fs.statSync(backupPath));
							const sizeMB = (stats.size / 1024 / 1024).toFixed(2);

							await interaction.editReply({
								content: `‚úÖ **Full Backup Created**\nüìÅ \`${backupPath}\`\nüìä Size: ${sizeMB} MB\n\nRetrieve with: \`scp user@server:${backupPath} ./\``
							});

							logInfo(`[BACKUP] Full backup created by ${user.username} (${sizeMB} MB)`);
						}
					} catch (e) {
						const errMsg = e instanceof Error ? e.message : String(e);
						await interaction.editReply(`‚ùå Backup failed: ${errMsg}`);
						logError("[BACKUP] Failed", errMsg);
					}
					break;
				}

				case "cost": {
					const view = interaction.options.getString("view") || "me";

					if (view === "me") {
						const userCost = analytics.getUserCost(user.id);
						if (!userCost) {
							await interaction.reply({
								content: "üìä **Your Usage**\nNo usage recorded yet. Start chatting to track costs!",
								ephemeral: true
							});
							break;
						}

						const embed = new EmbedBuilder()
							.setColor(0x00BFFF)
							.setTitle("üìä Your API Usage")
							.addFields(
								{ name: "Total Requests", value: String(userCost.requests), inline: true },
								{ name: "Estimated Cost", value: `$${userCost.estimatedCostUsd.toFixed(4)}`, inline: true },
								{ name: "Input Tokens", value: userCost.totalTokensInput.toLocaleString(), inline: true },
								{ name: "Output Tokens", value: userCost.totalTokensOutput.toLocaleString(), inline: true }
							)
							.setFooter({ text: `Last updated: ${userCost.lastUpdated}` });

						await interaction.reply({ embeds: [embed], ephemeral: true });
					} else if (view === "top") {
						const topUsers = analytics.getTopCostUsers(10);
						if (topUsers.length === 0) {
							await interaction.reply({
								content: "üìä **Top Users**\nNo usage recorded yet.",
								ephemeral: true
							});
							break;
						}

						const userList = topUsers.map((u, i) =>
							`${i + 1}. **${u.username}** - $${u.estimatedCostUsd.toFixed(4)} (${u.requests} requests)`
						).join("\n");

						const embed = new EmbedBuilder()
							.setColor(0xFFD700)
							.setTitle("üèÜ Top Users by Cost")
							.setDescription(userList);

						await interaction.reply({ embeds: [embed], ephemeral: true });
					} else if (view === "daily") {
						const dailyCosts = analytics.getDailyCosts(7);
						const totalWeek = dailyCosts.reduce((sum, d) => sum + d.cost, 0);

						const breakdown = dailyCosts.map(d =>
							`${d.date}: $${d.cost.toFixed(4)}`
						).join("\n");

						const embed = new EmbedBuilder()
							.setColor(0x32CD32)
							.setTitle("üìÖ Daily Cost Breakdown")
							.setDescription(breakdown || "No data yet")
							.addFields(
								{ name: "7-Day Total", value: `$${totalWeek.toFixed(4)}`, inline: true }
							);

						await interaction.reply({ embeds: [embed], ephemeral: true });
					}
					break;
				}

				default:
					await interaction.reply("Unknown command");
			}

			// Track successful command
			const responseTime = Date.now() - commandStartTime;
			analytics.trackCommand({
				type: "command",
				timestamp: new Date().toISOString(),
				userId: user.id,
				username: user.username,
				command: commandName,
				responseTime,
				model: model.id,
				channelId,
				channelName,
			});
		} catch (error) {
			const errMsg = error instanceof Error ? error.message : String(error);
			botStats.errorsCount++;
			logError(`Slash command error (/${commandName})`, errMsg);

			// Track error
			analytics.trackCommand({
				type: "error",
				timestamp: new Date().toISOString(),
				userId: user.id,
				username: user.username,
				command: commandName,
				error: errMsg,
				model: model.id,
				channelId,
				channelName,
			});

			if (interaction.deferred) {
				await interaction.editReply(`Error: ${errMsg.substring(0, 500)}`).catch(() => {});
			} else {
				await interaction.reply(`Error: ${errMsg.substring(0, 500)}`).catch(() => {});
			}
		}
	});

	// Handle button interactions
	client.on("interactionCreate", async (interaction) => {
		if (!interaction.isButton()) return;

		const { customId, user } = interaction;

		if (customId === "feedback_helpful") {
			await interaction.reply({ content: "Thanks for the feedback! üëç", ephemeral: true });
			logInfo(`[Feedback] ${user.username} found response helpful`);
		} else if (customId === "feedback_not_helpful") {
			await interaction.reply({ content: "Sorry to hear that. I'll try to do better! üëé", ephemeral: true });
			logInfo(`[Feedback] ${user.username} found response not helpful`);
		} else if (customId === "feedback_more") {
			await interaction.reply({ content: "Just ask me a follow-up question!", ephemeral: true });
		}
	});

	// Handle @mentions (keep existing functionality)
	client.on("messageCreate", async (message: Message) => {
		if (message.author.bot) return;

		const isMention = message.mentions.has(client.user!);
		const isDM = !message.guild;

		if (!isMention && !isDM) return;

		// CRITICAL: Deduplicate messages to prevent double responses
		if (!markMessageProcessed(message.id)) {
			logWarning(`Duplicate message detected, skipping: ${message.id}`);
			return;
		}

		const channelId = message.channel.id;
		const channelName = isDM ? `DM:${message.author.username}` : (message.channel as TextChannel).name || "unknown";

		let text = message.content;
		if (isMention && client.user) {
			text = text.replace(new RegExp(`<@!?${client.user.id}>`, "g"), "").trim();
		}

		// Handle file attachments
		const attachments = Array.from(message.attachments.values());
		if (attachments.length > 0) {
			const attachmentInfo = attachments.map(a =>
				`[Attached: ${a.name} (${a.contentType || 'unknown'}) - ${a.url}]`
			).join("\n");
			text = text ? `${text}\n\n${attachmentInfo}` : attachmentInfo;
			logInfo(`[${channelId}] Processing ${attachments.length} attachment(s)`);
		}

		if (!text && attachments.length === 0) return;

		logInfo(`[${channelName}] [msg:${message.id}] ${message.author.username}: ${text.substring(0, 80)}...`);

		// Handle text commands for /provider (so users can type it directly)
		if (text.toLowerCase().startsWith("/provider") || text.toLowerCase().startsWith("!provider")) {
			const parts = text.split(/\s+/);
			const subCommand = parts[1]?.toLowerCase();

			if (!subCommand || subCommand === "status") {
				const providerInfo = currentProvider === "openrouter"
					? `**OpenRouter** (Cloud)\nModel: ${OPENROUTER_MODELS[globalModelId]?.name || globalModelId}\nCost: ${OPENROUTER_MODELS[globalModelId]?.cost || "varies"}`
					: `**Ollama** (Local)\nModel: ${globalModelId}\nCost: FREE`;
				await message.reply(`üîå **Current Provider**\n${providerInfo}\n\nSwitch with:\n‚Ä¢ \`/provider openrouter\` - Cloud AI\n‚Ä¢ \`/provider ollama\` - Local AI`);
				return;
			}

			if (subCommand === "ollama") {
				currentProvider = "ollama";
				globalModelId = DEFAULT_MODEL_ID;
				channelStates.clear();
				logInfo(`[TEXT-CMD] Switched to Ollama by ${message.author.username}`);
				await message.reply(`‚úÖ Switched to **Ollama** (local, free)\nModel: \`${globalModelId}\``);
				return;
			}

			if (subCommand === "openrouter") {
				if (!OPENROUTER_API_KEY) {
					await message.reply("‚ùå OpenRouter API key not configured.");
					return;
				}
				const modelChoice = parts[2]?.toLowerCase() || DEFAULT_OPENROUTER_MODEL;
				const validModels = Object.keys(OPENROUTER_MODELS);
				const selectedModel = validModels.find(m => m.includes(modelChoice)) || DEFAULT_OPENROUTER_MODEL;

				currentProvider = "openrouter";
				globalModelId = selectedModel;
				channelStates.clear();

				const modelInfo = OPENROUTER_MODELS[selectedModel];
				logInfo(`[TEXT-CMD] Switched to OpenRouter (${modelInfo?.id}) by ${message.author.username}`);
				await message.reply(`‚úÖ Switched to **OpenRouter** (cloud)\nModel: \`${modelInfo?.name || selectedModel}\`\nCost: ${modelInfo?.cost || "varies"}`);
				return;
			}

			// Unknown subcommand - show help
			await message.reply(`Available models:\n${Object.entries(OPENROUTER_MODELS).map(([k, v]) => `‚Ä¢ \`${k}\` - ${v.name}`).join("\n")}\n\nUsage: \`/provider openrouter mistral-small\``);
			return;
		}

		// Track if we've already sent a response to prevent duplicates
		let responseSent = false;

		try {
			// Show typing indicator instead of status message
			if ("sendTyping" in message.channel) {
				await (message.channel as any).sendTyping();
			}

			// Single reply function that prevents duplicates
			const sendResponse = async (content: string) => {
				if (responseSent) return;
				responseSent = true;

				// Check for rich embed markers
				const embedMatch = content.match(/__EMBED__(.+?)__EMBED__/s);
				if (embedMatch) {
					try {
						const embedData = JSON.parse(embedMatch[1]);
						const embed = new EmbedBuilder()
							.setTitle(embedData.title || "Response")
							.setDescription(embedData.description || "")
							.setColor(embedData.color || 0x0099FF)
							.setTimestamp();

						if (embedData.fields) {
							embed.addFields(embedData.fields);
						}
						if (embedData.thumbnail?.url) {
							embed.setThumbnail(embedData.thumbnail.url);
						}
						if (embedData.footer?.text) {
							embed.setFooter({ text: embedData.footer.text });
						}

						// Send embed + any text outside the markers
						const textOutside = content.replace(/__EMBED__.+?__EMBED__/s, "").trim();
						if (textOutside) {
							await message.reply({ content: textOutside, embeds: [embed] });
						} else {
							await message.reply({ embeds: [embed] });
						}
						return;
					} catch {
						// If embed parsing fails, send as plain text
					}
				}

				await message.reply(content);
			};

			await handleAgentRequest(
				channelId,
				channelName,
				message.author.username,
				message.author.id,
				text,
				workingDir,
				sendResponse,  // reply callback
				sendResponse,  // editReply also uses same function (no editing)
				message,
			);
		} catch (error) {
			const errMsg = error instanceof Error ? error.message : String(error);
			logError("Error processing message", errMsg);

			if (!responseSent) {
				await message.reply(`_Error: ${errMsg.substring(0, 500)}_`).catch(() => {});
			}
		}
	});

	client.on("error", (error) => {
		logError("Discord client error", error.message);
	});

	process.on("SIGINT", () => {
		logInfo("Shutting down...");
		client.destroy();
		process.exit(0);
	});

	process.on("SIGTERM", () => {
		logInfo("Shutting down...");
		client.destroy();
		process.exit(0);
	});

	await client.login(DISCORD_BOT_TOKEN);

	// ========================================================================
	// Event-Driven Triggers: Cron Jobs & Webhooks
	// ========================================================================

	const REPORT_CHANNEL_ID = process.env.REPORT_CHANNEL_ID; // Channel for scheduled reports
	const WEBHOOK_PORT = parseInt(process.env.WEBHOOK_PORT || "3001", 10);

	// Multi-channel configuration
	const ALERTS_CHANNEL_ID = process.env.ALERTS_CHANNEL_ID;
	const SIGNALS_CHANNEL_ID = process.env.SIGNALS_CHANNEL_ID;
	const REPORTS_CHANNEL_ID = process.env.REPORTS_CHANNEL_ID;
	const LOGS_CHANNEL_ID = process.env.LOGS_CHANNEL_ID;

	// ChannelRouter: Routes messages to appropriate channels with fallback support
	class ChannelRouter {
		private client: Client;
		private fallbackChannelId: string | undefined;

		constructor(client: Client, fallbackChannelId?: string) {
			this.client = client;
			this.fallbackChannelId = fallbackChannelId;
		}

		private async sendToChannel(channelId: string | undefined, content: string): Promise<void> {
			const targetChannelId = channelId || this.fallbackChannelId;
			if (!targetChannelId) {
				logWarning("[CHANNEL_ROUTER] No channel configured and no fallback available");
				return;
			}

			try {
				const channel = await this.client.channels.fetch(targetChannelId);
				if (channel && "send" in channel) {
					await (channel as TextChannel).send(content);
				}
			} catch (error) {
				logError(
					`Failed to send to channel ${targetChannelId}`,
					error instanceof Error ? error.message : String(error)
				);
			}
		}

		async sendAlert(content: string): Promise<void> {
			await this.sendToChannel(ALERTS_CHANNEL_ID, content);
		}

		async sendSignal(content: string): Promise<void> {
			await this.sendToChannel(SIGNALS_CHANNEL_ID, content);
		}

		async sendReport(content: string): Promise<void> {
			await this.sendToChannel(REPORTS_CHANNEL_ID, content);
		}

		async sendLog(content: string): Promise<void> {
			await this.sendToChannel(LOGS_CHANNEL_ID, content);
		}

		async send(content: string, channelId?: string): Promise<void> {
			await this.sendToChannel(channelId, content);
		}
	}

	// Initialize channel router with backward compatibility
	const channelRouter = new ChannelRouter(client, REPORT_CHANNEL_ID);

	// Helper: Send message to report channel (maintained for backward compatibility)
	async function sendToReportChannel(content: string): Promise<void> {
		await channelRouter.sendReport(content);
	}

	// Daily trading system health check (9 AM UTC)
	cron.schedule("0 9 * * *", async () => {
		logInfo("[CRON] Running daily trading system health check");
		try {
			const result = await execCommand(`
				echo "=== Trading System Daily Report ==="
				echo "Date: $(date)"
				echo ""
				echo "=== System Resources ==="
				free -h | head -2
				echo ""
				echo "=== Trading Processes ==="
				ps aux | grep -E 'python.*trad|collector' | grep -v grep | head -5 || echo "No trading processes found"
				echo ""
				echo "=== Recent Errors (last 24h) ==="
				find /home/majinbu/organized/active-projects/trading-system/quant/rbi_bench/ -name "*.log" -mtime 0 -exec grep -l -i error {} \\; 2>/dev/null | head -5 || echo "No error logs found"
			`);
			await sendToReportChannel(`**Daily Trading Report**\n\`\`\`\n${result.stdout.substring(0, 1800)}\n\`\`\``);
		} catch (error) {
			logError("[CRON] Health check failed", error instanceof Error ? error.message : String(error));
		}
	});

	// Hourly quick status check
	cron.schedule("0 * * * *", async () => {
		logInfo("[CRON] Running hourly status check");
		try {
			const result = await execCommand(`
				echo "Uptime: $(uptime -p)"
				echo "Load: $(cat /proc/loadavg | cut -d' ' -f1-3)"
				echo "Memory: $(free -h | awk '/Mem:/ {print $3 "/" $2}')"
			`);
			// Only log, don't send to channel every hour
			logInfo(`[CRON] Status: ${result.stdout.replace(/\n/g, " | ").trim()}`);
		} catch (error) {
			logError("[CRON] Status check failed", error instanceof Error ? error.message : String(error));
		}
	});

	// Daily analytics summary (midnight UTC)
	cron.schedule("0 0 * * *", async () => {
		logInfo("[CRON] Generating daily analytics summary");
		try {
			const yesterday = new Date();
			yesterday.setDate(yesterday.getDate() - 1);

			const summary = analytics.generateDailySummary(yesterday);
			const dateStr = yesterday.toISOString().split("T")[0];
			const summaryPath = join(workingDir, "analytics", `summary-${dateStr}.md`);

			writeFileSync(summaryPath, summary);
			logInfo(`[CRON] Daily analytics summary saved to ${summaryPath}`);

			// Optionally send to report channel
			if (REPORT_CHANNEL_ID) {
				await sendToReportChannel(`**Daily Analytics Summary - ${dateStr}**\n\`\`\`\n${summary.substring(0, 1800)}\n\`\`\``);
			}
		} catch (error) {
			logError("[CRON] Analytics summary failed", error instanceof Error ? error.message : String(error));
		}
	});

	// Weekly analytics cleanup (Sunday at 3 AM)
	cron.schedule("0 3 * * 0", async () => {
		logInfo("[CRON] Running analytics cleanup");
		try {
			const deletedCount = analytics.cleanup(90); // Keep 90 days
			logInfo(`[CRON] Cleaned up ${deletedCount} old analytics files`);
		} catch (error) {
			logError("[CRON] Analytics cleanup failed", error instanceof Error ? error.message : String(error));
		}
	});

	// Webhook server for external alerts
	const webhookApp = express();
	webhookApp.use(express.json());

	// API Key Authentication Middleware
	const WEBHOOK_API_KEY = process.env.WEBHOOK_API_KEY;

	function authenticateApiKey(req: express.Request, res: express.Response, next: express.NextFunction): void {
		// Skip auth for health endpoint
		if (req.path === "/health") {
			next();
			return;
		}

		// Check for API key in header or query param
		const apiKeyHeader = req.headers["x-api-key"] as string | undefined;
		const apiKeyQuery = req.query.api_key as string | undefined;
		const providedKey = apiKeyHeader || apiKeyQuery;

		if (!WEBHOOK_API_KEY) {
			logWarning("[WEBHOOK] WEBHOOK_API_KEY not configured - authentication disabled");
			next();
			return;
		}

		if (!providedKey) {
			logWarning(`[WEBHOOK] Unauthorized attempt from ${req.ip} - no API key provided`);
			res.status(401).json({ error: "Unauthorized - API key required" });
			return;
		}

		if (providedKey !== WEBHOOK_API_KEY) {
			logWarning(`[WEBHOOK] Unauthorized attempt from ${req.ip} - invalid API key`);
			res.status(401).json({ error: "Unauthorized - invalid API key" });
			return;
		}

		// Authentication successful
		next();
	}

	// Apply authentication middleware to all routes
	webhookApp.use(authenticateApiKey);

	// Price alert webhook
	webhookApp.post("/webhook/alert", async (req, res) => {
		try {
			const { message, priority, type } = req.body;
			if (!message) {
				res.status(400).json({ error: "Missing message" });
				return;
			}

			const prefix = priority === "high" ? "**ALERT**" : "**Alert**";
			const content = `${prefix}: ${message}`;

			// Route based on type field, default to alert channel
			if (type === "alert" || !type) {
				await channelRouter.sendAlert(content);
			} else {
				await sendToReportChannel(content);
			}

			logInfo(`[WEBHOOK] Alert received: ${message.substring(0, 50)}...`);
			res.json({ status: "ok" });
		} catch (error) {
			logError("[WEBHOOK] Alert handling failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// Trading signal webhook
	webhookApp.post("/webhook/signal", async (req, res) => {
		try {
			const { symbol, action, price, reason, type } = req.body;
			if (!symbol || !action) {
				res.status(400).json({ error: "Missing symbol or action" });
				return;
			}

			const msg = `**Trading Signal**\nSymbol: \`${symbol}\`\nAction: **${action}**\nPrice: ${price || "N/A"}\nReason: ${reason || "N/A"}`;

			// Route based on type field, default to signal channel
			if (type === "signal" || !type) {
				await channelRouter.sendSignal(msg);
			} else {
				await sendToReportChannel(msg);
			}

			logInfo(`[WEBHOOK] Signal: ${symbol} ${action}`);
			res.json({ status: "ok" });
		} catch (error) {
			logError("[WEBHOOK] Signal handling failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// GitHub webhook (for PR/Issue notifications)
	webhookApp.post("/webhook/github", async (req, res) => {
		try {
			const event = req.headers["x-github-event"] as string;
			const { action, repository, pull_request, issue, sender, type } = req.body;

			let msg = "";
			if (event === "pull_request") {
				msg = `**GitHub PR ${action}**\nRepo: \`${repository?.full_name}\`\nPR: #${pull_request?.number} - ${pull_request?.title}\nBy: ${sender?.login}`;
			} else if (event === "issues") {
				msg = `**GitHub Issue ${action}**\nRepo: \`${repository?.full_name}\`\nIssue: #${issue?.number} - ${issue?.title}\nBy: ${sender?.login}`;
			} else if (event === "push") {
				msg = `**GitHub Push**\nRepo: \`${repository?.full_name}\`\nBy: ${sender?.login}`;
			} else {
				msg = `**GitHub Event**: ${event} (${action || "N/A"})`;
			}

			// Route based on type field, default to log channel
			if (type === "log" || !type) {
				await channelRouter.sendLog(msg);
			} else {
				await sendToReportChannel(msg);
			}

			logInfo(`[WEBHOOK] GitHub: ${event} ${action || ""}`);
			res.json({ status: "ok" });
		} catch (error) {
			logError("[WEBHOOK] GitHub handling failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// Agent task webhook (trigger agent to do something)
	webhookApp.post("/webhook/agent", async (req, res) => {
		try {
			const { task, channel_id, model: reqModel } = req.body;
			if (!task) {
				res.status(400).json({ error: "Missing task" });
				return;
			}

			const targetChannel = channel_id || REPORT_CHANNEL_ID;
			logInfo(`[WEBHOOK] Agent task: ${task.substring(0, 50)}...`);

			// Execute via opencode CLI
			const { exec } = await import("child_process");
			const { promisify } = await import("util");
			const execAsync = promisify(exec);

			const modelArg = reqModel ? `-m ${reqModel}` : "";
			const cmd = `timeout 60 opencode run "${task.replace(/"/g, '\\"')}" ${modelArg} 2>&1 | head -100`;

			try {
				const { stdout } = await execAsync(cmd, { maxBuffer: 512 * 1024 });
				await sendToReportChannel(`**Agent Task Result:**\nTask: ${task.substring(0, 100)}\n\`\`\`\n${stdout.substring(0, 1500)}\n\`\`\``);
				res.json({ status: "ok", result: stdout.substring(0, 500) });
			} catch (e: any) {
				await sendToReportChannel(`**Agent Task Failed:**\nTask: ${task.substring(0, 100)}\nError: ${e.message}`);
				res.json({ status: "error", error: e.message });
			}
		} catch (error) {
			logError("[WEBHOOK] Agent task failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// Scheduled task webhook (for cron-like external triggers)
	webhookApp.post("/webhook/scheduled", async (req, res) => {
		try {
			const { task_name, payload, type } = req.body;
			if (!task_name) {
				res.status(400).json({ error: "Missing task_name" });
				return;
			}

			logInfo(`[WEBHOOK] Scheduled task: ${task_name}`);

			// Handle different scheduled tasks
			let msg = "";
			switch (task_name) {
				case "daily_summary":
					msg = `**Daily Summary Triggered**\n${JSON.stringify(payload || {}, null, 2)}`;
					break;
				case "health_check":
					const uptime = process.uptime();
					msg = `**Health Check**\nUptime: ${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m\nChannels: ${channelStates.size}\nModel: ${model.id}`;
					break;
				default:
					msg = `**Scheduled Task: ${task_name}**\n${JSON.stringify(payload || {}, null, 2)}`;
			}

			// Route based on type field, default to report channel
			if (type === "report" || !type) {
				await channelRouter.sendReport(msg);
			} else if (type === "log") {
				await channelRouter.sendLog(msg);
			} else {
				await sendToReportChannel(msg);
			}

			res.json({ status: "ok" });
		} catch (error) {
			logError("[WEBHOOK] Scheduled task failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// Custom message webhook (send any message to a channel)
	webhookApp.post("/webhook/message", async (req, res) => {
		try {
			const { channel_id, message, embed, type } = req.body;
			if (!message && !embed) {
				res.status(400).json({ error: "Missing message or embed" });
				return;
			}

			// Determine target channel based on type or explicit channel_id
			let targetChannel = channel_id;
			if (!targetChannel && type) {
				// Map type to channel ID
				switch (type) {
					case "alert":
						targetChannel = ALERTS_CHANNEL_ID || REPORT_CHANNEL_ID;
						break;
					case "signal":
						targetChannel = SIGNALS_CHANNEL_ID || REPORT_CHANNEL_ID;
						break;
					case "report":
						targetChannel = REPORTS_CHANNEL_ID || REPORT_CHANNEL_ID;
						break;
					case "log":
						targetChannel = LOGS_CHANNEL_ID || REPORT_CHANNEL_ID;
						break;
					default:
						targetChannel = REPORT_CHANNEL_ID;
				}
			} else if (!targetChannel) {
				targetChannel = REPORT_CHANNEL_ID;
			}

			if (!targetChannel) {
				res.status(400).json({ error: "No target channel" });
				return;
			}

			const channel = client.channels.cache.get(targetChannel) as TextChannel;
			if (!channel) {
				res.status(404).json({ error: "Channel not found" });
				return;
			}

			if (embed) {
				const embedObj = new EmbedBuilder()
					.setTitle(embed.title || "Notification")
					.setDescription(embed.description || message)
					.setColor(embed.color || 0x0099FF)
					.setTimestamp();
				await channel.send({ embeds: [embedObj] });
			} else {
				await channel.send(message);
			}

			logInfo(`[WEBHOOK] Message sent to ${targetChannel}`);
			res.json({ status: "ok" });
		} catch (error) {
			logError("[WEBHOOK] Message failed", error instanceof Error ? error.message : String(error));
			res.status(500).json({ error: "Internal error" });
		}
	});

	// Health check endpoint
	webhookApp.get("/health", (req, res) => {
		res.json({
			status: "ok",
			uptime: process.uptime(),
			model: model.id,
			channels: channelStates.size,
			tools: 35, // Updated count
			skills: 32,
		});
	});

	// List available webhook endpoints
	webhookApp.get("/webhooks", (req, res) => {
		res.json({
			endpoints: [
				{ path: "/webhook/alert", method: "POST", description: "Send alert message" },
				{ path: "/webhook/signal", method: "POST", description: "Trading signal notification" },
				{ path: "/webhook/github", method: "POST", description: "GitHub event notifications" },
				{ path: "/webhook/agent", method: "POST", description: "Trigger agent task" },
				{ path: "/webhook/scheduled", method: "POST", description: "Scheduled task trigger" },
				{ path: "/webhook/message", method: "POST", description: "Send custom message to channel" },
				{ path: "/health", method: "GET", description: "Health check" },
				{ path: "/webhooks", method: "GET", description: "List endpoints (this)" },
			],
		});
	});

	// Real Metrics API Endpoints
	webhookApp.get("/api/status", (req, res) => {
		const uptime = Math.floor((Date.now() - botStats.startTime) / 1000);
		res.json({
			status: "ok",
			uptime,
			model: globalModelId,
			provider: currentProvider,
			commands: botStats.commandsProcessed,
			messages: botStats.messagesProcessed,
			errors: botStats.errorsCount,
			activeUsers: botStats.userInteractions.size,
			channels: channelStates.size,
		});
	});

	webhookApp.get("/api/metrics", (req, res) => {
		const uptime = Math.floor((Date.now() - botStats.startTime) / 1000);
		const memUsage = process.memoryUsage();

		res.json({
			uptime,
			memory: {
				heapUsed: memUsage.heapUsed,
				heapTotal: memUsage.heapTotal,
				rss: memUsage.rss,
				external: memUsage.external,
			},
			stats: {
				commands: botStats.commandsProcessed,
				messages: botStats.messagesProcessed,
				errors: botStats.errorsCount,
				errorRate: botStats.messagesProcessed > 0
					? (botStats.errorsCount / botStats.messagesProcessed * 100).toFixed(2) + "%"
					: "0%",
			},
			users: {
				total: botStats.userInteractions.size,
				active: Array.from(botStats.userInteractions.values())
					.filter(u => Date.now() - u.lastSeen < 3600000).length,
			},
			channels: channelStates.size,
			rateLimits: {
				userLimit: "20/min",
				globalLimit: "100/min",
			},
		});
	});

	webhookApp.get("/api/tools", (req, res) => {
		const tools = getToolUsageStats();
		res.json({
			total: tools.length,
			tools: tools.slice(0, 50),
		});
	});

	webhookApp.get("/api/users", (req, res) => {
		const users = Array.from(botStats.userInteractions.entries())
			.map(([id, data]) => ({
				id,
				username: data.username,
				requests: data.count,
				lastSeen: new Date(data.lastSeen).toISOString(),
			}))
			.sort((a, b) => b.requests - a.requests)
			.slice(0, 50);

		res.json({ total: botStats.userInteractions.size, users });
	});

	// Serve dashboard static files
	webhookApp.use("/dashboard", express.static(join(workingDir, "dashboard")));

	webhookApp.listen(WEBHOOK_PORT, () => {
		logInfo(`[WEBHOOK] Server listening on port ${WEBHOOK_PORT}`);
	});

	// ========================================================================
	// Analytics Dashboard API (Port 9090)
	// ========================================================================

	const DASHBOARD_PORT = parseInt(process.env.DASHBOARD_PORT || "9090", 10);
	const dashboardApp = express();
	dashboardApp.use(express.json());

	// CORS headers for dashboard
	dashboardApp.use((req, res, next) => {
		res.header("Access-Control-Allow-Origin", "*");
		res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
		res.header("Access-Control-Allow-Headers", "Content-Type");
		if (req.method === "OPTIONS") {
			return res.sendStatus(200);
		}
		next();
	});

	// Main analytics endpoint
	dashboardApp.get("/api/analytics", (req, res) => {
		try {
			const period = (req.query.period as "today" | "week" | "all") || "today";
			const stats = analytics.getStats(period);
			const commandStats = analytics.getCommandStats();
			const userStats = analytics.getUserStats();
			const hourlyDist = analytics.getHourlyDistribution();
			const modelUsage = analytics.getModelUsage();

			res.json({
				period,
				summary: stats,
				commands: commandStats.slice(0, 10),
				users: userStats.slice(0, 20),
				hourlyDistribution: hourlyDist,
				modelUsage,
				timestamp: new Date().toISOString(),
			});
		} catch (error) {
			const errMsg = error instanceof Error ? error.message : String(error);
			res.status(500).json({ error: errMsg });
		}
	});

	// Command-specific stats
	dashboardApp.get("/api/analytics/commands", (req, res) => {
		try {
			const commandStats = analytics.getCommandStats();
			res.json(commandStats);
		} catch (error) {
			const errMsg = error instanceof Error ? error.message : String(error);
			res.status(500).json({ error: errMsg });
		}
	});

	// User activity stats
	dashboardApp.get("/api/analytics/users", (req, res) => {
		try {
			const userStats = analytics.getUserStats();
			res.json(userStats);
		} catch (error) {
			const errMsg = error instanceof Error ? error.message : String(error);
			res.status(500).json({ error: errMsg });
		}
	});

	// Health check for dashboard
	dashboardApp.get("/api/health", (req, res) => {
		res.json({
			status: "ok",
			uptime: process.uptime(),
			model: model.id,
			channels: channelStates.size,
			analyticsEnabled: true,
		});
	});

	dashboardApp.listen(DASHBOARD_PORT, () => {
		logInfo(`[DASHBOARD] Analytics API listening on port ${DASHBOARD_PORT}`);
		logInfo(`[DASHBOARD] Access analytics at http://localhost:${DASHBOARD_PORT}/api/analytics`);
	});

	logInfo("Event-driven triggers initialized (cron jobs + webhooks + analytics)");
}

main().catch((error) => {
	logError("Fatal error", error instanceof Error ? error.message : String(error));
	process.exit(1);
});
