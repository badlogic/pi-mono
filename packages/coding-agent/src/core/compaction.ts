/**
 * Context compaction for long sessions.
 *
 * Pure functions for compaction logic. The session manager handles I/O,
 * and after compaction the session is reloaded.
 */

import type { AppMessage } from "@mariozechner/pi-agent-core";
import type { AssistantMessage, Model, ToolCall, ToolResultMessage, Usage } from "@mariozechner/pi-ai";
import { complete } from "@mariozechner/pi-ai";
import { messageTransformer } from "./messages.js";
import { type CompactionEntry, createSummaryMessage, type SessionEntry } from "./session-manager.js";

/**
 * Extract AppMessage from an entry if it produces one.
 * Returns null for entries that don't contribute to LLM context.
 */
function getMessageFromEntry(entry: SessionEntry): AppMessage | null {
	if (entry.type === "message") {
		return entry.message;
	}
	if (entry.type === "custom_message") {
		return {
			role: "user",
			content: entry.content,
			timestamp: new Date(entry.timestamp).getTime(),
		};
	}
	if (entry.type === "branch_summary") {
		return createSummaryMessage(entry.summary, entry.timestamp);
	}
	return null;
}

/** Result from compact() - SessionManager adds uuid/parentUuid when saving */
export interface CompactionResult<T = unknown> {
	summary: string;
	firstKeptEntryId: string;
	tokensBefore: number;
	/** Hook-specific data (e.g., ArtifactIndex, version markers for structured compaction) */
	details?: T;
}

// ============================================================================
// Types
// ============================================================================

export interface CompactionSettings {
	enabled: boolean;
	reserveTokens: number;
	keepRecentTokens: number;
}

export const DEFAULT_COMPACTION_SETTINGS: CompactionSettings = {
	enabled: true,
	reserveTokens: 16384,
	keepRecentTokens: 20000,
};

/**
 * Summary version marker embedded in summary text.
 * Used to detect v2 summaries for backward compatibility.
 */
export const SUMMARY_V2_MARKER = "<!-- PI_COMPACTION_SUMMARY_V2 -->";

/**
 * Maximum token budget for summary output.
 * Kept conservative to avoid cost/latency and drift issues.
 */
export const SUMMARY_TOKEN_BUDGET = 2000;

// ============================================================================
// Artifact Index - Deterministic extraction from tool calls
// ============================================================================

/**
 * Command execution record for artifact tracking.
 */
export interface CommandRecord {
	cmd: string;
	exitCode?: number;
	keyOutput?: string;
}

/**
 * Test execution record for artifact tracking.
 */
export interface TestRecord {
	cmd: string;
	result: "pass" | "fail" | "error" | "unknown";
	failures?: string[];
}

/**
 * Tracked file with frequency count for artifact tracking.
 */
export interface FileRecord {
	path: string;
	count: number;
}

/**
 * Generic tool call record for tracking non-built-in tools.
 */
export interface ToolCallRecord {
	/** Tool name (e.g., "codemap", "subagent") */
	name: string;
	/** Formatted key parameters (e.g., "path=src/, seed=auth login") */
	params: string;
}

/**
 * Deterministic artifact index extracted from tool calls.
 * Populated by scanning messages/tool calls/tool results, NOT by LLM summarization.
 * Errors are NOT tracked here - they are extracted by the LLM during summarization.
 */
export interface ArtifactIndex {
	/** Files read, with frequency count, in order of first access */
	filesRead: FileRecord[];
	/** Files modified (via edit), with frequency count, in order of first modification */
	filesModified: FileRecord[];
	/** Files created (via write), with frequency count, in order of first creation */
	filesCreated: FileRecord[];
	/** Commands run (bash), in order of execution */
	commandsRun: CommandRecord[];
	/** Generic tool calls (non-built-in tools), in order of execution */
	toolCalls: ToolCallRecord[];
	/** Test results detected from bash output */
	tests: TestRecord[];
}

/**
 * Structured summary format with fixed sections.
 * This is the internal representation; serialized to/from markdown.
 */
export interface StructuredSummaryV2 {
	version: 2;
	sessionIntent: string[];
	constraintsAndPreferences: string[];
	currentState: {
		done: string[];
		inProgress: string[];
		blocked: string[];
	};
	artifactIndex: ArtifactIndex;
	decisions: Array<{ decision: string; rationale: string }>;
	nextSteps: string[];
	openQuestions: string[];
	deadEnds: string[];
	/** Errors and issues encountered during the session (extracted by LLM) */
	errors: string[];
	/** Test results validated/generated by LLM (not auto-detected) */
	tests: TestRecord[];
}

/**
 * Create an empty artifact index.
 */
export function createEmptyArtifactIndex(): ArtifactIndex {
	return {
		filesRead: [],
		filesModified: [],
		filesCreated: [],
		commandsRun: [],
		toolCalls: [],
		tests: [],
	};
}

/**
 * Extract artifact index from a span of messages.
 * Scans tool calls and tool results to deterministically extract file paths and commands.
 * Tracks frequency (count) and preserves order of first occurrence.
 */
export function extractArtifactIndex(messages: AppMessage[]): ArtifactIndex {
	const index = createEmptyArtifactIndex();

	// Track file frequencies with order preservation
	const filesReadMap = new Map<string, number>();
	const filesReadOrder: string[] = [];
	const filesModifiedMap = new Map<string, number>();
	const filesModifiedOrder: string[] = [];
	const filesCreatedMap = new Map<string, number>();
	const filesCreatedOrder: string[] = [];

	// Map toolCallId -> bash command for correlation with tool results
	const bashCommandMap = new Map<string, string>();

	// Track which bash commands we've seen and their array index for updates
	// This avoids duplicates between tool calls and bashExecution messages
	const bashCommandIndex = new Map<string, number>();

	const trackFile = (path: string, map: Map<string, number>, order: string[]) => {
		const count = map.get(path) ?? 0;
		if (count === 0) {
			order.push(path);
		} else {
			// Move to end for true recency (LRU style)
			const idx = order.indexOf(path);
			if (idx !== -1) {
				order.splice(idx, 1);
				order.push(path);
			}
		}
		map.set(path, count + 1);
	};

	// Helper to track bash commands with deduplication.
	// If the same command is seen again with richer data (exitCode, keyOutput),
	// update the existing entry rather than adding a duplicate.
	const trackBashCommand = (cmd: string, exitCode?: number, keyOutput?: string) => {
		const key = cmd.trim();
		const existingIdx = bashCommandIndex.get(key);
		if (existingIdx !== undefined) {
			// Update existing entry if new data is richer
			const existing = index.commandsRun[existingIdx];
			if (exitCode !== undefined && existing.exitCode === undefined) {
				existing.exitCode = exitCode;
			}
			if (keyOutput && !existing.keyOutput) {
				existing.keyOutput = keyOutput;
			}
			return;
		}
		bashCommandIndex.set(key, index.commandsRun.length);
		index.commandsRun.push({ cmd, exitCode, keyOutput });
	};

	for (const msg of messages) {
		// Extract from assistant messages (tool calls)
		if (msg.role === "assistant") {
			const assistantMsg = msg as AssistantMessage;
			for (const content of assistantMsg.content) {
				if (content.type === "toolCall") {
					const toolCall = content as ToolCall;

					// Track bash commands for later correlation with results
					if (toolCall.name === "bash") {
						const args = toolCall.arguments as Record<string, unknown>;
						if (typeof args.command === "string") {
							bashCommandMap.set(toolCall.id, args.command);
						}
					}

					extractFromToolCall(
						toolCall,
						(p) => trackFile(p, filesReadMap, filesReadOrder),
						(p) => trackFile(p, filesModifiedMap, filesModifiedOrder),
						(p) => trackFile(p, filesCreatedMap, filesCreatedOrder),
						index,
						trackBashCommand,
					);
				}
			}
		}

		// Extract from tool results (for test detection)
		if (msg.role === "toolResult") {
			const toolResult = msg as ToolResultMessage<any>;
			extractFromToolResult(toolResult, index, bashCommandMap);
		}

		// Extract from bash execution messages (prefer these as they have exit code/output)
		if (msg.role === "bashExecution") {
			const bash = msg as unknown as { command: string; output: string; exitCode: number | null };
			trackBashCommand(bash.command, bash.exitCode ?? undefined, truncateKeyOutput(bash.output));
		}
	}

	// Convert maps to FileRecord arrays preserving order
	index.filesRead = filesReadOrder.map((path) => ({ path, count: filesReadMap.get(path)! }));
	index.filesModified = filesModifiedOrder.map((path) => ({ path, count: filesModifiedMap.get(path)! }));
	index.filesCreated = filesCreatedOrder.map((path) => ({ path, count: filesCreatedMap.get(path)! }));

	return index;
}

/**
 * Format tool parameters for display in artifact tracking.
 * Extracts key parameters and formats them as "key=value, key2=value2".
 * Truncates long values and skips empty/null values.
 */
function formatToolParams(args: Record<string, unknown>): string {
	const parts: string[] = [];
	const maxValueLen = 50;

	for (const [key, value] of Object.entries(args)) {
		if (value === null || value === undefined || value === "") continue;

		let formatted: string;
		if (typeof value === "string") {
			formatted = value.length > maxValueLen ? `${value.slice(0, maxValueLen)}...` : value;
		} else if (typeof value === "number" || typeof value === "boolean") {
			formatted = String(value);
		} else if (Array.isArray(value)) {
			formatted = `[${value.length} items]`;
		} else {
			formatted = "{...}";
		}

		parts.push(`${key}=${formatted}`);
	}

	return parts.join(", ");
}

/**
 * Extract artifacts from a tool call.
 */
function extractFromToolCall(
	toolCall: ToolCall,
	trackRead: (path: string) => void,
	trackModified: (path: string) => void,
	trackCreated: (path: string) => void,
	index: ArtifactIndex,
	trackBashCommand: (cmd: string, exitCode?: number, keyOutput?: string) => void,
): void {
	const args = toolCall.arguments as Record<string, unknown>;

	switch (toolCall.name) {
		case "read":
			if (typeof args.path === "string") {
				trackRead(args.path);
			}
			break;

		case "edit":
			if (typeof args.path === "string") {
				trackModified(args.path);
			}
			break;

		case "write":
			if (typeof args.path === "string") {
				// Could be create or modify - we track as created
				// (accurate tracking would require checking file existence)
				trackCreated(args.path);
			}
			break;

		case "bash":
			if (typeof args.command === "string") {
				// Use the deduplicating tracker - bashExecution messages will also call this
				// but with richer data (exit code, output), so duplicates are merged
				trackBashCommand(args.command);
			}
			break;

		case "grep":
		case "find":
		case "ls":
			// These are read-only exploration tools, no file tracking needed
			break;

		default:
			// Generic tracking for custom/unknown tools
			index.toolCalls.push({
				name: toolCall.name,
				params: formatToolParams(args),
			});
			break;
	}
}

/**
 * Check if a bash command looks like a test command.
 * Returns true for common test runners and patterns.
 */
function isTestCommand(cmd: string): boolean {
	const normalized = cmd.toLowerCase();

	// Common test runner commands
	const testPatterns = [
		/\bnpm\s+(run\s+)?test\b/,
		/\bpnpm\s+(run\s+)?test\b/,
		/\byarn\s+(run\s+)?test\b/,
		/\bbun\s+test\b/,
		/\bvitest\b/,
		/\bjest\b/,
		/\bmocha\b/,
		/\bava\b/,
		/\btap\b/,
		/\bpytest\b/,
		/\bpython.*-m\s+(unittest|pytest)\b/,
		/\bgo\s+test\b/,
		/\bcargo\s+test\b/,
		/\bmake\s+test\b/,
		/\brspec\b/,
		/\bruby.*_test\.rb\b/,
		/\bphpunit\b/,
		/\bdotnet\s+test\b/,
		/\bmvn\s+test\b/,
		/\bgradle\s+test\b/,
	];

	return testPatterns.some((pattern) => pattern.test(normalized));
}

/**
 * Detect test results from output text.
 * Returns null if output doesn't look like test runner output.
 * Uses specific patterns to avoid false positives from git diff, etc.
 */
function detectTestResult(text: string): { result: "pass" | "fail" | "unknown"; failures: string[] } | null {
	// Look for specific test runner output patterns (not just "PASS" or "FAIL" anywhere)
	const testOutputPatterns = [
		// Jest/Vitest: "Tests:  1 passed" or "Test Suites: 1 passed"
		/Tests?:\s+\d+\s+(passed|failed)/i,
		// Jest/Vitest: "✓" or "✕" test markers
		/[✓✕]\s+.+\(\d+\s*m?s\)/,
		// Pytest: "passed", "failed", "error" with counts
		/\d+\s+(passed|failed|error)/,
		// Go test: "--- PASS:" or "--- FAIL:"
		/---\s+(PASS|FAIL):/,
		// Generic: "X tests passed" or "X tests failed"
		/\d+\s+tests?\s+(passed|failed)/i,
		// Mocha/tap style: "passing" / "failing" with counts
		/\d+\s+(passing|failing)/,
	];

	const looksLikeTestOutput = testOutputPatterns.some((pattern) => pattern.test(text));
	if (!looksLikeTestOutput) return null;

	// Determine pass/fail status
	const hasFailure =
		/[✕]\s+/.test(text) ||
		/FAIL[:\s]/i.test(text) ||
		/\d+\s+failed/i.test(text) ||
		/\d+\s+failing/.test(text) ||
		/Tests:\s+\d+\s+failed/i.test(text);

	const hasPass =
		/[✓]\s+/.test(text) ||
		/PASS[:\s]/i.test(text) ||
		/\d+\s+passed/i.test(text) ||
		/\d+\s+passing/.test(text) ||
		/Tests:\s+\d+\s+passed/i.test(text);

	const result: "pass" | "fail" | "unknown" = hasFailure ? "fail" : hasPass ? "pass" : "unknown";

	// Extract failure details (Jest/Vitest style)
	const failures: string[] = [];
	const failureMatches = text.match(/[✕]\s+(.+)/g);
	if (failureMatches) {
		for (const match of failureMatches.slice(0, 5)) {
			failures.push(match.replace(/[✕]\s+/, "").slice(0, 100));
		}
	}

	return { result, failures };
}

/**
 * Extract artifacts from a tool result.
 * Only extracts test results from bash output. Errors are handled by LLM summarization.
 */
function extractFromToolResult(
	toolResult: ToolResultMessage<any>,
	index: ArtifactIndex,
	bashCommandMap: Map<string, string>,
): void {
	// Tests: only attempt to detect test output for bash tool results.
	if (toolResult.toolName !== "bash") return;

	const cmd = bashCommandMap.get(toolResult.toolCallId) ?? "";

	// First check: command must look like a test command
	if (!isTestCommand(cmd)) return;

	const text = toolResult.content
		.filter((c): c is { type: "text"; text: string } => c.type === "text" && typeof c.text === "string")
		.map((c) => c.text)
		.join("\n");

	if (!text) return;

	// Second check: output must look like test runner output
	const testResult = detectTestResult(text);
	if (!testResult) return;

	index.tests.push({
		cmd,
		result: testResult.result,
		failures: testResult.failures.length > 0 ? testResult.failures : undefined,
	});
}

/**
 * Truncate key output to a reasonable length for artifact tracking.
 */
function truncateKeyOutput(output: string, maxLength = 200): string {
	if (!output) return "";
	if (output.length <= maxLength) return output;
	return `${output.slice(0, maxLength)}...`;
}

/**
 * Merge two artifact indices, combining file frequencies and preserving order.
 */
export function mergeArtifactIndices(base: ArtifactIndex, incoming: ArtifactIndex): ArtifactIndex {
	return {
		filesRead: mergeFileRecords(base.filesRead, incoming.filesRead),
		filesModified: mergeFileRecords(base.filesModified, incoming.filesModified),
		filesCreated: mergeFileRecords(base.filesCreated, incoming.filesCreated),
		commandsRun: [...base.commandsRun, ...incoming.commandsRun],
		toolCalls: [...base.toolCalls, ...incoming.toolCalls],
		tests: [...base.tests, ...incoming.tests],
	};
}

/**
 * Merge file records, combining counts for same paths while preserving order.
 */
function mergeFileRecords(base: FileRecord[], incoming: FileRecord[]): FileRecord[] {
	const merged = new Map<string, number>();
	const order: string[] = [];

	for (const rec of base) {
		if (!merged.has(rec.path)) order.push(rec.path);
		merged.set(rec.path, (merged.get(rec.path) ?? 0) + rec.count);
	}
	for (const rec of incoming) {
		// Move to end for true recency when merging
		const existingIdx = order.indexOf(rec.path);
		if (existingIdx !== -1) {
			order.splice(existingIdx, 1);
		}
		order.push(rec.path);
		merged.set(rec.path, (merged.get(rec.path) ?? 0) + rec.count);
	}

	return order.map((path) => ({ path, count: merged.get(path)! }));
}

/**
 * Get top N files by frequency, sorted descending.
 */
function getTopByFrequency(files: FileRecord[], n: number): FileRecord[] {
	return [...files].sort((a, b) => b.count - a.count).slice(0, n);
}

/**
 * Get most recent N files (from end of array, preserving recency order).
 * Excludes files already in the common set.
 */
function getMostRecent(files: FileRecord[], n: number, excludePaths: Set<string>): FileRecord[] {
	const recent: FileRecord[] = [];
	for (let i = files.length - 1; i >= 0 && recent.length < n; i--) {
		if (!excludePaths.has(files[i].path)) {
			recent.push(files[i]);
		}
	}
	return recent;
}

/**
 * Format file records for markdown output with frequency/recency labels.
 */
function formatFileSection(files: FileRecord[], label: string, lines: string[]): void {
	if (files.length === 0) return;

	const TOP_N = 10;
	const topCommon = getTopByFrequency(files, TOP_N);
	const commonPaths = new Set(topCommon.map((f) => f.path));
	const topRecent = getMostRecent(files, TOP_N, commonPaths);

	lines.push(`**${label}:**`);

	// Most common files (with frequency)
	for (const f of topCommon) {
		const freq = f.count > 1 ? ` (${f.count}x)` : "";
		lines.push(`- ${f.path}${freq}`);
	}

	// Most recent files (not in common)
	for (const f of topRecent) {
		lines.push(`- ${f.path} (recent)`);
	}

	const shown = topCommon.length + topRecent.length;
	if (files.length > shown) {
		lines.push(`- ... and ${files.length - shown} more`);
	}

	lines.push("");
}

/**
 * Format commands for markdown output with frequency/recency.
 */
function formatCommandSection(commands: CommandRecord[], lines: string[]): void {
	if (commands.length === 0) return;

	const TOP_N = 10;

	// Count command frequencies (normalize by trimming)
	const freqMap = new Map<string, number>();
	const order: string[] = [];
	for (const c of commands) {
		const key = c.cmd.trim();
		if (!freqMap.has(key)) order.push(key);
		freqMap.set(key, (freqMap.get(key) ?? 0) + 1);
	}

	// Get top by frequency
	const sorted = order.map((cmd) => ({ cmd, count: freqMap.get(cmd)! })).sort((a, b) => b.count - a.count);
	const topCommon = sorted.slice(0, TOP_N);
	const commonCmds = new Set(topCommon.map((c) => c.cmd));

	// Get most recent (not in common)
	const topRecent: CommandRecord[] = [];
	for (let i = commands.length - 1; i >= 0 && topRecent.length < TOP_N; i--) {
		const key = commands[i].cmd.trim();
		if (!commonCmds.has(key)) {
			topRecent.push(commands[i]);
			commonCmds.add(key); // avoid duplicates in recent
		}
	}

	lines.push("**Commands Run:**");

	// Most common
	for (const c of topCommon) {
		const freq = c.count > 1 ? ` (${c.count}x)` : "";
		lines.push(`- \`${c.cmd.slice(0, 100)}\`${freq}`);
	}

	// Most recent
	for (const c of topRecent) {
		const exitStr = c.exitCode !== undefined ? ` exit ${c.exitCode}` : "";
		lines.push(`- \`${c.cmd.slice(0, 100)}\` (recent${exitStr})`);
	}

	const shown = topCommon.length + topRecent.length;
	if (order.length > shown) {
		lines.push(`- ... and ${order.length - shown} more`);
	}

	lines.push("");
}

/**
 * Format tool calls for markdown output with frequency/recency.
 */
function formatToolCallSection(toolCalls: ToolCallRecord[], lines: string[]): void {
	if (toolCalls.length === 0) return;

	const TOP_N = 10;

	// Count tool call frequencies by "name(params)" key
	const freqMap = new Map<string, number>();
	const order: string[] = [];
	for (const t of toolCalls) {
		const key = `${t.name}(${t.params})`;
		if (!freqMap.has(key)) order.push(key);
		freqMap.set(key, (freqMap.get(key) ?? 0) + 1);
	}

	// Get top by frequency
	const sorted = order.map((key) => ({ key, count: freqMap.get(key)! })).sort((a, b) => b.count - a.count);
	const topCommon = sorted.slice(0, TOP_N);
	const commonKeys = new Set(topCommon.map((t) => t.key));

	// Get most recent (not in common)
	const topRecent: ToolCallRecord[] = [];
	for (let i = toolCalls.length - 1; i >= 0 && topRecent.length < TOP_N; i--) {
		const key = `${toolCalls[i].name}(${toolCalls[i].params})`;
		if (!commonKeys.has(key)) {
			topRecent.push(toolCalls[i]);
			commonKeys.add(key); // avoid duplicates in recent
		}
	}

	lines.push("**Tools Used:**");

	// Most common
	for (const t of topCommon) {
		const freq = t.count > 1 ? ` (${t.count}x)` : "";
		lines.push(`- ${t.key.slice(0, 120)}${freq}`);
	}

	// Most recent
	for (const t of topRecent) {
		lines.push(`- ${t.name}(${t.params.slice(0, 100)}) (recent)`);
	}

	const shown = topCommon.length + topRecent.length;
	if (order.length > shown) {
		lines.push(`- ... and ${order.length - shown} more`);
	}

	lines.push("");
}

/**
 * Serialize artifact index to markdown section.
 * Shows top 10 most common (by frequency) + top 10 most recent for files and commands.
 * Note: Tests are NOT included here - they are in the main summary's Tests section.
 */
export function artifactIndexToMarkdown(index: ArtifactIndex): string {
	const lines: string[] = [];

	formatFileSection(index.filesRead, "Files Read", lines);
	formatFileSection(index.filesModified, "Files Modified", lines);
	formatFileSection(index.filesCreated, "Files Created", lines);
	formatCommandSection(index.commandsRun, lines);
	formatToolCallSection(index.toolCalls, lines);

	// Tests are intentionally NOT included here - they are in the main summary's Tests section
	// The artifact index tests are only used as hints for the LLM

	return lines.join("\n");
}

/**
 * Parse artifact index from markdown section.
 * Returns null if section is empty or not found.
 * Handles both old format (simple paths) and new format (with frequency/recency annotations).
 */
export function parseArtifactIndexFromMarkdown(markdown: string): ArtifactIndex | null {
	const index = createEmptyArtifactIndex();

	type Section = "filesRead" | "filesModified" | "filesCreated" | "commandsRun" | "toolCalls" | null;
	let section: Section = null;

	const lines = markdown.split("\n");
	for (const line of lines) {
		const trimmed = line.trim();

		// Section headers
		switch (trimmed) {
			case "**Files Read:**":
				section = "filesRead";
				continue;
			case "**Files Modified:**":
				section = "filesModified";
				continue;
			case "**Files Created:**":
				section = "filesCreated";
				continue;
			case "**Commands Run:**":
				section = "commandsRun";
				continue;
			case "**Tools Used:**":
				section = "toolCalls";
				continue;
		}

		if (!trimmed) continue;

		// Parse items by section
		switch (section) {
			case "filesRead":
			case "filesModified":
			case "filesCreated": {
				const match = trimmed.match(/^[-*•]\s+(.+)$/);
				if (!match) break;
				let pathPart = match[1].trim();
				if (!pathPart || pathPart.startsWith("...")) break;

				// Extract count from "(Nx)" or mark as 1 for "(recent)" or no annotation
				let count = 1;
				const freqMatch = pathPart.match(/^(.+?)\s+\((\d+)x\)$/);
				const recentMatch = pathPart.match(/^(.+?)\s+\(recent\)$/);
				if (freqMatch) {
					pathPart = freqMatch[1].trim();
					count = parseInt(freqMatch[2], 10);
				} else if (recentMatch) {
					pathPart = recentMatch[1].trim();
					count = 1;
				}

				const record: FileRecord = { path: pathPart, count };
				if (section === "filesRead") index.filesRead.push(record);
				else if (section === "filesModified") index.filesModified.push(record);
				else index.filesCreated.push(record);
				break;
			}

			case "commandsRun": {
				// Match: `cmd` (Nx) or `cmd` (recent) or `cmd` (recent exit N) or `cmd` (exit N)
				const match = trimmed.match(/^[-*•]\s+`(.+?)`(?:\s+\((.+?)\))?$/);
				if (!match) break;
				const cmd = match[1].trim();
				if (!cmd || cmd.startsWith("...")) break;

				let exitCode: number | undefined;
				const annotation = match[2] || "";
				const exitMatch = annotation.match(/exit\s+(\d+)/);
				if (exitMatch) {
					exitCode = parseInt(exitMatch[1], 10);
				}

				index.commandsRun.push({ cmd, exitCode });
				break;
			}

			case "toolCalls": {
				// Match: name(params) (Nx) or name(params) (recent) or name(params)
				const match = trimmed.match(/^[-*•]\s+(.+?)\((.+?)\)(?:\s+\((?:\d+x|recent)\))?$/);
				if (!match) break;
				const name = match[1].trim();
				const params = match[2].trim();
				if (!name || name.startsWith("...")) break;

				index.toolCalls.push({ name, params });
				break;
			}
		}
	}

	// Deduplicate file lists by path, summing counts
	index.filesRead = dedupeFileRecords(index.filesRead);
	index.filesModified = dedupeFileRecords(index.filesModified);
	index.filesCreated = dedupeFileRecords(index.filesCreated);

	const hasData =
		index.filesRead.length > 0 ||
		index.filesModified.length > 0 ||
		index.filesCreated.length > 0 ||
		index.commandsRun.length > 0 ||
		index.toolCalls.length > 0 ||
		index.tests.length > 0;

	return hasData ? index : null;
}

/**
 * Deduplicate file records by path, summing counts while preserving first occurrence order.
 */
function dedupeFileRecords(records: FileRecord[]): FileRecord[] {
	const map = new Map<string, number>();
	const order: string[] = [];
	for (const rec of records) {
		if (!map.has(rec.path)) order.push(rec.path);
		map.set(rec.path, (map.get(rec.path) ?? 0) + rec.count);
	}
	return order.map((path) => ({ path, count: map.get(path)! }));
}

/**
 * Create an empty structured summary.
 */
export function createEmptyStructuredSummary(): StructuredSummaryV2 {
	return {
		version: 2,
		sessionIntent: [],
		constraintsAndPreferences: [],
		currentState: {
			done: [],
			inProgress: [],
			blocked: [],
		},
		artifactIndex: createEmptyArtifactIndex(),
		decisions: [],
		nextSteps: [],
		openQuestions: [],
		deadEnds: [],
		errors: [],
		tests: [],
	};
}

/**
 * Check if a summary string is v2 format.
 */
export function isV2Summary(summary: string): boolean {
	return summary.includes(SUMMARY_V2_MARKER);
}

/**
 * Serialize structured summary to markdown.
 */
export function structuredSummaryToMarkdown(summary: StructuredSummaryV2): string {
	const lines: string[] = [SUMMARY_V2_MARKER, ""];

	// Session Intent
	lines.push("## Session Intent");
	if (summary.sessionIntent.length > 0) {
		for (const item of summary.sessionIntent) {
			lines.push(`- ${item}`);
		}
	} else {
		lines.push("(none recorded)");
	}
	lines.push("");

	// Constraints & Preferences
	lines.push("## Constraints & Preferences");
	if (summary.constraintsAndPreferences.length > 0) {
		for (const item of summary.constraintsAndPreferences) {
			lines.push(`- ${item}`);
		}
	} else {
		lines.push("(none recorded)");
	}
	lines.push("");

	// Current State
	lines.push("## Current State");
	lines.push("### Done");
	if (summary.currentState.done.length > 0) {
		for (const item of summary.currentState.done) {
			lines.push(`- [x] ${item}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	lines.push("### In Progress");
	if (summary.currentState.inProgress.length > 0) {
		for (const item of summary.currentState.inProgress) {
			lines.push(`- [ ] ${item}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	lines.push("### Blocked");
	if (summary.currentState.blocked.length > 0) {
		for (const item of summary.currentState.blocked) {
			lines.push(`- ⚠ ${item}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	// Artifact Index
	lines.push("## Artifact Index");
	const artifactMd = artifactIndexToMarkdown(summary.artifactIndex);
	if (artifactMd.trim()) {
		lines.push(artifactMd);
	} else {
		lines.push("(no artifacts tracked)");
		lines.push("");
	}

	// Errors / Issues (extracted by LLM)
	lines.push("## Errors / Issues");
	if (summary.errors.length > 0) {
		for (const e of summary.errors) {
			lines.push(`- ${e}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	// Tests (LLM-validated)
	lines.push("## Tests");
	if (summary.tests.length > 0) {
		for (const t of summary.tests) {
			const statusIcon = t.result === "pass" ? "✓" : t.result === "fail" ? "✗" : "?";
			lines.push(`- ${statusIcon} ${t.cmd}`);
			if (t.failures) {
				for (const f of t.failures.slice(0, 3)) {
					lines.push(`  - ${f}`);
				}
			}
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	// Decisions
	lines.push("## Decisions");
	if (summary.decisions.length > 0) {
		for (const d of summary.decisions) {
			lines.push(`- **${d.decision}**: ${d.rationale}`);
		}
	} else {
		lines.push("(none recorded)");
	}
	lines.push("");

	// Next Steps
	lines.push("## Next Steps");
	if (summary.nextSteps.length > 0) {
		for (let i = 0; i < summary.nextSteps.length; i++) {
			lines.push(`${i + 1}. ${summary.nextSteps[i]}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	// Open Questions
	lines.push("## Open Questions");
	if (summary.openQuestions.length > 0) {
		for (const q of summary.openQuestions) {
			lines.push(`- ${q}`);
		}
	} else {
		lines.push("(none)");
	}
	lines.push("");

	// Dead Ends / Do-Not-Repeat
	lines.push("## Dead Ends / Do-Not-Repeat");
	if (summary.deadEnds.length > 0) {
		for (const item of summary.deadEnds) {
			lines.push(`- ${item}`);
		}
	} else {
		lines.push("(none)");
	}

	return lines.join("\n");
}

/**
 * Parse structured summary from markdown.
 * Returns null if parsing fails or format is not v2.
 */
export function parseStructuredSummaryFromMarkdown(markdown: string): StructuredSummaryV2 | null {
	if (!isV2Summary(markdown)) {
		return null;
	}

	const summary = createEmptyStructuredSummary();

	// Parse Session Intent
	const intentMatch = markdown.match(/## Session Intent\n([\s\S]*?)(?=\n## |$)/);
	if (intentMatch) {
		summary.sessionIntent = extractBulletItems(intentMatch[1]);
	}

	// Parse Constraints & Preferences
	const constraintsMatch = markdown.match(/## Constraints & Preferences\n([\s\S]*?)(?=\n## |$)/);
	if (constraintsMatch) {
		summary.constraintsAndPreferences = extractBulletItems(constraintsMatch[1]);
	}

	// Parse Current State - Done
	const doneMatch = markdown.match(/### Done\n([\s\S]*?)(?=\n### |$)/);
	if (doneMatch) {
		summary.currentState.done = extractChecklistItems(doneMatch[1], true);
	}

	// Parse Current State - In Progress
	const progressMatch = markdown.match(/### In Progress\n([\s\S]*?)(?=\n### |\n## |$)/);
	if (progressMatch) {
		summary.currentState.inProgress = extractChecklistItems(progressMatch[1], false);
	}

	// Parse Current State - Blocked
	const blockedMatch = markdown.match(/### Blocked\n([\s\S]*?)(?=\n### |\n## |$)/);
	if (blockedMatch) {
		summary.currentState.blocked = extractBlockedItems(blockedMatch[1]);
	}

	// Parse Artifact Index
	const artifactMatch = markdown.match(/## Artifact Index\n([\s\S]*?)(?=\n## |$)/);
	if (artifactMatch) {
		const parsed = parseArtifactIndexFromMarkdown(artifactMatch[1]);
		if (parsed) {
			summary.artifactIndex = parsed;
		}
	}

	// Parse Errors / Issues
	const errorsMatch = markdown.match(/## Errors \/ Issues\n([\s\S]*?)(?=\n## |$)/);
	if (errorsMatch) {
		summary.errors = extractBulletItems(errorsMatch[1]);
	}

	// Parse Decisions
	const decisionsMatch = markdown.match(/## Decisions\n([\s\S]*?)(?=\n## |$)/);
	if (decisionsMatch) {
		const lines = decisionsMatch[1].split("\n");
		for (const line of lines) {
			const match = line.trim().match(/^[-*•]\s+\*\*(.+?)\*\*:\s*(.*)$/);
			if (match) {
				summary.decisions.push({ decision: match[1], rationale: match[2] });
			}
		}
	}

	// Parse Next Steps
	const nextMatch = markdown.match(/## Next Steps\n([\s\S]*?)(?=\n## |$)/);
	if (nextMatch) {
		const lines = nextMatch[1].split("\n").filter((l) => /^\s*\d+\.\s/.test(l));
		for (const line of lines) {
			const content = line.replace(/^\s*\d+\.\s*/, "").trim();
			if (content && content !== "(none)") {
				summary.nextSteps.push(content);
			}
		}
	}

	// Parse Open Questions
	const questionsMatch = markdown.match(/## Open Questions\n([\s\S]*?)(?=\n## |$)/);
	if (questionsMatch) {
		summary.openQuestions = extractBulletItems(questionsMatch[1]);
	}

	// Parse Dead Ends
	const deadEndsMatch = markdown.match(/## Dead Ends \/ Do-Not-Repeat\n([\s\S]*?)(?=\n## |$)/);
	if (deadEndsMatch) {
		summary.deadEnds = extractBulletItems(deadEndsMatch[1]);
	}

	// Parse Tests
	const testsMatch = markdown.match(/## Tests\n([\s\S]*?)(?=\n## |$)/);
	if (testsMatch) {
		summary.tests = extractTestItems(testsMatch[1]);
	}

	return summary;
}

/**
 * Extract bullet items from a section.
 *
 * Accepts "-", "*", and "•" bullets. Ignores explicit "(none)" markers.
 */
function extractBulletItems(text: string): string[] {
	const items: string[] = [];
	for (const line of text.split("\n")) {
		const trimmed = line.trim();
		const match = trimmed.match(/^[-*•]\s+(.+)$/);
		if (!match) continue;

		const content = match[1].trim();
		if (!content) continue;

		const lower = content.toLowerCase();
		if (lower === "(none)" || lower === "(none recorded)") continue;

		items.push(content);
	}
	return items;
}

/**
 * Extract checklist items (`- [x]` or `- [ ]`) from a section.
 *
 * Accepts "-", "*", and "•" bullets.
 */
function extractChecklistItems(text: string, checked: boolean): string[] {
	const items: string[] = [];
	const re = checked ? /^[-*•]\s+\[x\]\s+(.+)$/i : /^[-*•]\s+\[ \]\s+(.+)$/;
	for (const line of text.split("\n")) {
		const trimmed = line.trim();
		const match = trimmed.match(re);
		if (!match) continue;

		const content = match[1].trim();
		if (content && content !== "(none)") {
			items.push(content);
		}
	}
	return items;
}

/**
 * Extract blocked items from a section (format: "- ⚠ item").
 *
 * Accepts "-", "*", and "•" bullets.
 */
function extractBlockedItems(text: string): string[] {
	const items: string[] = [];
	for (const line of text.split("\n")) {
		const trimmed = line.trim();
		const match = trimmed.match(/^[-*•]\s+⚠\s+(.+)$/);
		if (!match) continue;

		const content = match[1].trim();
		if (content && content !== "(none)") {
			items.push(content);
		}
	}
	return items;
}

/**
 * Extract test items from a Tests section.
 * Format: "- ✓ command" for pass, "- ✗ command" for fail, "- ? command" for unknown
 * Failure details are indented sub-bullets.
 */
function extractTestItems(text: string): TestRecord[] {
	const tests: TestRecord[] = [];
	let currentTest: TestRecord | null = null;

	for (const line of text.split("\n")) {
		const trimmed = line.trim();

		// Match test line: "- ✓ cmd" or "- ✗ cmd" or "- ? cmd"
		const testMatch = trimmed.match(/^[-*•]\s+([✓✗?])\s+(.+)$/);
		if (testMatch) {
			const icon = testMatch[1];
			const cmd = testMatch[2].trim();
			const result: TestRecord["result"] = icon === "✓" ? "pass" : icon === "✗" ? "fail" : "unknown";
			currentTest = { cmd, result };
			tests.push(currentTest);
			continue;
		}

		// Match failure sub-bullet (indented)
		const failureMatch = line.match(/^\s{2,}[-*•]\s+(.+)$/);
		if (failureMatch && currentTest) {
			const failure = failureMatch[1].trim();
			if (failure) {
				currentTest.failures ??= [];
				currentTest.failures.push(failure);
			}
		}
	}

	return tests;
}

/**
 * Convert v1 (legacy) summary to v2 structured format.
 * The v1 summary becomes the "Session Intent" and other sections are empty.
 */
export function convertV1ToV2Summary(v1Summary: string): StructuredSummaryV2 {
	const summary = createEmptyStructuredSummary();

	// Try to extract meaningful content from v1 summary
	// The v1 summary is free-form, so we put it in session intent as a single item
	const trimmed = v1Summary.trim();
	if (trimmed) {
		// Split by common section markers if present
		const lines = trimmed.split("\n");
		let currentSection = "intent";

		for (const line of lines) {
			const lower = line.toLowerCase();

			// Try to detect sections in v1 format
			if (lower.includes("next step") || lower.includes("remaining") || lower.includes("todo")) {
				currentSection = "next";
			} else if (lower.includes("decision") || lower.includes("chose") || lower.includes("decided")) {
				currentSection = "decision";
			} else if (lower.includes("blocked") || lower.includes("issue") || lower.includes("problem")) {
				currentSection = "blocked";
			} else if (lower.includes("done") || lower.includes("completed") || lower.includes("finished")) {
				currentSection = "done";
			}

			// Extract bullet points
			const bulletMatch = line.match(/^[-*•]\s*(.+)/);
			const numberedMatch = line.match(/^\d+\.\s*(.+)/);
			const content = bulletMatch ? bulletMatch[1] : numberedMatch ? numberedMatch[1] : null;

			if (content) {
				switch (currentSection) {
					case "next":
						summary.nextSteps.push(content);
						break;
					case "decision":
						summary.decisions.push({ decision: content, rationale: "" });
						break;
					case "blocked":
						summary.currentState.blocked.push(content);
						break;
					case "done":
						summary.currentState.done.push(content);
						break;
					default:
						summary.sessionIntent.push(content);
				}
			} else if (line.trim() && currentSection === "intent" && !line.startsWith("#")) {
				// Non-bullet lines in intent section
				summary.sessionIntent.push(line.trim());
			}
		}

		// If we couldn't extract structure, just use the whole thing as intent
		if (summary.sessionIntent.length === 0 && summary.nextSteps.length === 0) {
			summary.sessionIntent.push(trimmed.slice(0, 500));
		}
	}

	return summary;
}

// ============================================================================
// Token calculation
// ============================================================================

/**
 * Calculate total context tokens from usage.
 * Uses the native totalTokens field when available, falls back to computing from components.
 */
export function calculateContextTokens(usage: Usage): number {
	return usage.totalTokens || usage.input + usage.output + usage.cacheRead + usage.cacheWrite;
}

/**
 * Get usage from an assistant message if available.
 * Skips aborted and error messages as they don't have valid usage data.
 */
function getAssistantUsage(msg: AppMessage): Usage | null {
	if (msg.role === "assistant" && "usage" in msg) {
		const assistantMsg = msg as AssistantMessage;
		if (assistantMsg.stopReason !== "aborted" && assistantMsg.stopReason !== "error" && assistantMsg.usage) {
			return assistantMsg.usage;
		}
	}
	return null;
}

/**
 * Find the last non-aborted assistant message usage from session entries.
 */
export function getLastAssistantUsage(entries: SessionEntry[]): Usage | null {
	for (let i = entries.length - 1; i >= 0; i--) {
		const entry = entries[i];
		if (entry.type === "message") {
			const usage = getAssistantUsage(entry.message);
			if (usage) return usage;
		}
	}
	return null;
}

/**
 * Check if compaction should trigger based on context usage.
 */
export function shouldCompact(contextTokens: number, contextWindow: number, settings: CompactionSettings): boolean {
	if (!settings.enabled) return false;
	return contextTokens > contextWindow - settings.reserveTokens;
}

// ============================================================================
// Cut point detection
// ============================================================================

/**
 * Estimate token count for a message using chars/4 heuristic.
 * This is conservative (overestimates tokens).
 */
export function estimateTokens(message: AppMessage): number {
	let chars = 0;

	// Handle bashExecution messages
	if (message.role === "bashExecution") {
		const bash = message as unknown as { command: string; output: string };
		chars = bash.command.length + bash.output.length;
		return Math.ceil(chars / 4);
	}

	// Handle user messages
	if (message.role === "user") {
		const content = (message as { content: string | Array<{ type: string; text?: string }> }).content;
		if (typeof content === "string") {
			chars = content.length;
		} else if (Array.isArray(content)) {
			for (const block of content) {
				if (block.type === "text" && block.text) {
					chars += block.text.length;
				}
			}
		}
		return Math.ceil(chars / 4);
	}

	// Handle assistant messages
	if (message.role === "assistant") {
		const assistant = message as AssistantMessage;
		for (const block of assistant.content) {
			if (block.type === "text") {
				chars += block.text.length;
			} else if (block.type === "thinking") {
				chars += block.thinking.length;
			} else if (block.type === "toolCall") {
				chars += block.name.length + JSON.stringify(block.arguments).length;
			}
		}
		return Math.ceil(chars / 4);
	}

	// Handle tool results
	if (message.role === "toolResult") {
		const toolResult = message as { content: Array<{ type: string; text?: string }> };
		for (const block of toolResult.content) {
			if (block.type === "text" && block.text) {
				chars += block.text.length;
			}
		}
		return Math.ceil(chars / 4);
	}

	return 0;
}

/**
 * Find valid cut points: indices of user, assistant, or bashExecution messages.
 * Never cut at tool results (they must follow their tool call).
 * When we cut at an assistant message with tool calls, its tool results follow it
 * and will be kept.
 * BashExecutionMessage is treated like a user message (user-initiated context).
 */
function findValidCutPoints(entries: SessionEntry[], startIndex: number, endIndex: number): number[] {
	const cutPoints: number[] = [];
	for (let i = startIndex; i < endIndex; i++) {
		const entry = entries[i];
		// branch_summary and custom_message are user-role messages, valid cut points
		if (entry.type === "branch_summary" || entry.type === "custom_message") {
			cutPoints.push(i);
		} else if (entry.type === "message") {
			const role = entry.message.role;
			// user, assistant, and bashExecution are valid cut points
			// toolResult must stay with its preceding tool call
			if (role === "user" || role === "assistant" || role === "bashExecution") {
				cutPoints.push(i);
			}
		}
	}
	return cutPoints;
}

/**
 * Find the user message (or bashExecution) that starts the turn containing the given entry index.
 * Returns -1 if no turn start found before the index.
 * BashExecutionMessage is treated like a user message for turn boundaries.
 */
export function findTurnStartIndex(entries: SessionEntry[], entryIndex: number, startIndex: number): number {
	for (let i = entryIndex; i >= startIndex; i--) {
		const entry = entries[i];
		// branch_summary and custom_message are user-role messages, can start a turn
		if (entry.type === "branch_summary" || entry.type === "custom_message") {
			return i;
		}
		if (entry.type === "message") {
			const role = entry.message.role;
			if (role === "user" || role === "bashExecution") {
				return i;
			}
		}
	}
	return -1;
}

export interface CutPointResult {
	/** Index of first entry to keep */
	firstKeptEntryIndex: number;
	/** Index of user message that starts the turn being split, or -1 if not splitting */
	turnStartIndex: number;
	/** Whether this cut splits a turn (cut point is not a user message) */
	isSplitTurn: boolean;
}

/**
 * Find the cut point in session entries that keeps approximately `keepRecentTokens`.
 *
 * Algorithm: Walk backwards from newest, accumulating estimated message sizes.
 * Stop when we've accumulated >= keepRecentTokens. Cut at that point.
 *
 * Can cut at user OR assistant messages (never tool results). When cutting at an
 * assistant message with tool calls, its tool results come after and will be kept.
 *
 * Returns CutPointResult with:
 * - firstKeptEntryIndex: the entry index to start keeping from
 * - turnStartIndex: if cutting mid-turn, the user message that started that turn
 * - isSplitTurn: whether we're cutting in the middle of a turn
 *
 * Only considers entries between `startIndex` and `endIndex` (exclusive).
 */
export function findCutPoint(
	entries: SessionEntry[],
	startIndex: number,
	endIndex: number,
	keepRecentTokens: number,
): CutPointResult {
	const cutPoints = findValidCutPoints(entries, startIndex, endIndex);

	if (cutPoints.length === 0) {
		return { firstKeptEntryIndex: startIndex, turnStartIndex: -1, isSplitTurn: false };
	}

	// Walk backwards from newest, accumulating estimated message sizes
	let accumulatedTokens = 0;
	let cutIndex = startIndex; // Default: keep everything in range

	for (let i = endIndex - 1; i >= startIndex; i--) {
		const entry = entries[i];
		if (entry.type !== "message") continue;

		// Estimate this message's size
		const messageTokens = estimateTokens(entry.message);
		accumulatedTokens += messageTokens;

		// Check if we've exceeded the budget
		if (accumulatedTokens >= keepRecentTokens) {
			// Find the closest valid cut point at or after this entry
			for (let c = 0; c < cutPoints.length; c++) {
				if (cutPoints[c] >= i) {
					cutIndex = cutPoints[c];
					break;
				}
			}
			break;
		}
	}

	// Scan backwards from cutIndex to include any non-message entries (bash, settings, etc.)
	while (cutIndex > startIndex) {
		const prevEntry = entries[cutIndex - 1];
		// Stop at compaction boundaries
		if (prevEntry.type === "compaction") {
			break;
		}
		if (prevEntry.type === "message") {
			// Stop if we hit any message
			break;
		}
		// Include this non-message entry (bash, settings change, etc.)
		cutIndex--;
	}

	// Determine if this is a split turn
	const cutEntry = entries[cutIndex];
	const isUserMessage = cutEntry.type === "message" && cutEntry.message.role === "user";
	const turnStartIndex = isUserMessage ? -1 : findTurnStartIndex(entries, cutIndex, startIndex);

	return {
		firstKeptEntryIndex: cutIndex,
		turnStartIndex,
		isSplitTurn: !isUserMessage && turnStartIndex !== -1,
	};
}

// ============================================================================
// Summarization Prompts - V2 Structured
// ============================================================================

const INITIAL_SUMMARY_V2_PROMPT = `You are creating an INITIAL STRUCTURED SUMMARY for context compaction.

The conversation up to this point is being compacted. Create a structured summary following the EXACT template below.

RULES:
- Preserve EXACT file paths, function names, class names, and error strings - never paraphrase
- Be precise and factual - no speculation or invented information
- Each section must use the exact heading format shown
- If a section has no information, write "(none)" or leave bullets empty
- Keep each bullet concise but complete
- The Artifact Index section (files, commands) is tracked automatically and merged separately
- For the Tests section, you will receive auto-detected hints - validate and correct them based on context

OUTPUT TEMPLATE (use exactly these headings):

## Session Intent
- [1-3 bullets: What is the user trying to accomplish?]

## Constraints & Preferences
- [Bullets: Any constraints, preferences, or requirements mentioned by user]

## Current State
### Done
- [x] [Tasks/features completed]

### In Progress
- [ ] [Tasks currently being worked on]

### Blocked
- ⚠ [Issues blocking progress]

## Errors / Issues
- [Any errors, failures, or issues encountered - preserve exact error messages]

## Tests
- [Test commands run and their results. Use format: "✓ command" for pass, "✗ command" for fail, "? command" for unknown]
- [Review the auto-detected hints provided and correct any false positives or add missed tests]

## Decisions
- **[Decision made]**: [Brief rationale]

## Next Steps
1. [Ordered list of what should happen next]

## Open Questions
- [Questions that need answers or user input]

## Dead Ends / Do-Not-Repeat
- [Approaches tried that failed, with brief reason]`;

const UPDATE_SUMMARY_V2_PROMPT = `You are UPDATING an existing structured summary for context compaction.

IMPORTANT: You are performing an INCREMENTAL update. You have:
1. PREVIOUS_SUMMARY: The existing structured summary (preserved from prior compactions)
2. DROPPED_SPAN: New messages since the last compaction that are now being dropped

Your task: MERGE new information from DROPPED_SPAN into PREVIOUS_SUMMARY.

RULES:
- PRESERVE all existing file paths, function names, error strings from PREVIOUS_SUMMARY
- ADD new durable information from DROPPED_SPAN
- NEVER remove or paraphrase existing entries unless they are clearly superseded
- Move items from "In Progress" to "Done" when completed
- Move items from "Blocked" to "Done" or remove when fixed
- Update "Next Steps" based on what was accomplished
- The Artifact Index section (files, commands) is tracked automatically and merged separately
- For the Tests section, validate auto-detected hints and incorporate with existing test history
- Output must follow the EXACT template structure

OUTPUT TEMPLATE (use exactly these headings):

## Session Intent
- [Preserve existing + add if new intent emerged]

## Constraints & Preferences
- [Preserve existing + add new ones]

## Current State
### Done
- [x] [Completed items - add newly completed]

### In Progress
- [ ] [Current work - update based on progress]

### Blocked
- ⚠ [Current blockers]

## Errors / Issues
- [Preserve existing errors, add new ones encountered, mark resolved if fixed]

## Tests
- [Preserve existing test results, add new ones. Use format: "✓ command" for pass, "✗ command" for fail]
- [Review auto-detected hints and correct any errors]

## Decisions
- **[Decision]**: [Rationale] (preserve all, add new)

## Next Steps
1. [Update based on progress]

## Open Questions
- [Add new, remove answered]

## Dead Ends / Do-Not-Repeat
- [Add new failed approaches]`;

const REQUIRED_V2_SECTION_HEADINGS: RegExp[] = [
	/^##\s+Session Intent\s*$/m,
	/^##\s+Constraints & Preferences\s*$/m,
	/^##\s+Current State\s*$/m,
	/^###\s+Done\s*$/m,
	/^###\s+In Progress\s*$/m,
	/^###\s+Blocked\s*$/m,
	/^##\s+Errors \/ Issues\s*$/m,
	/^##\s+Tests\s*$/m,
	/^##\s+Decisions\s*$/m,
	/^##\s+Next Steps\s*$/m,
	/^##\s+Open Questions\s*$/m,
	/^##\s+Dead Ends \/ Do-Not-Repeat\s*$/m,
];

function hasRequiredV2Headings(rawMarkdown: string): boolean {
	return REQUIRED_V2_SECTION_HEADINGS.every((re) => re.test(rawMarkdown));
}

function containsExplicitNoneMarkers(rawMarkdown: string): boolean {
	return /\(none(?: recorded)?\)/i.test(rawMarkdown);
}

function countNonArtifactSummaryItems(summary: StructuredSummaryV2): number {
	return (
		summary.sessionIntent.length +
		summary.constraintsAndPreferences.length +
		summary.currentState.done.length +
		summary.currentState.inProgress.length +
		summary.currentState.blocked.length +
		summary.decisions.length +
		summary.nextSteps.length +
		summary.openQuestions.length +
		summary.deadEnds.length +
		summary.errors.length +
		summary.tests.length
	);
}

function cloneStructuredSummary(summary: StructuredSummaryV2): StructuredSummaryV2 {
	return {
		version: 2,
		sessionIntent: [...summary.sessionIntent],
		constraintsAndPreferences: [...summary.constraintsAndPreferences],
		currentState: {
			done: [...summary.currentState.done],
			inProgress: [...summary.currentState.inProgress],
			blocked: [...summary.currentState.blocked],
		},
		artifactIndex: {
			filesRead: summary.artifactIndex.filesRead.map((f) => ({ ...f })),
			filesModified: summary.artifactIndex.filesModified.map((f) => ({ ...f })),
			filesCreated: summary.artifactIndex.filesCreated.map((f) => ({ ...f })),
			commandsRun: summary.artifactIndex.commandsRun.map((c) => ({ ...c })),
			toolCalls: summary.artifactIndex.toolCalls.map((t) => ({ ...t })),
			tests: summary.artifactIndex.tests.map((t) => ({
				...t,
				failures: t.failures ? [...t.failures] : undefined,
			})),
		},
		decisions: summary.decisions.map((d) => ({ ...d })),
		nextSteps: [...summary.nextSteps],
		openQuestions: [...summary.openQuestions],
		deadEnds: [...summary.deadEnds],
		errors: [...summary.errors],
		tests: summary.tests.map((t) => ({
			...t,
			failures: t.failures ? [...t.failures] : undefined,
		})),
	};
}

function isValidStructuredSummaryV2Output(rawMarkdown: string, parsed: StructuredSummaryV2): boolean {
	if (!hasRequiredV2Headings(rawMarkdown)) return false;

	const nonArtifactCount = countNonArtifactSummaryItems(parsed);
	if (nonArtifactCount > 0) return true;

	// Allow "all none" summaries if the model followed the template closely.
	return containsExplicitNoneMarkers(rawMarkdown);
}

function isValidStructuredSummaryV2UpdateOutput(
	rawMarkdown: string,
	previousSummary: StructuredSummaryV2,
	parsed: StructuredSummaryV2,
): boolean {
	if (!isValidStructuredSummaryV2Output(rawMarkdown, parsed)) return false;

	// Guard against wiping the anchor summary due to formatting/parsing issues.
	const prevCount = countNonArtifactSummaryItems(previousSummary);
	const newCount = countNonArtifactSummaryItems(parsed);
	if (prevCount > 0 && newCount === 0) return false;

	return true;
}

/**
 * Format auto-detected tests as hints for the LLM.
 */
function formatTestHints(tests: TestRecord[]): string {
	if (tests.length === 0) {
		return "";
	}

	const lines = ["AUTO-DETECTED TEST HINTS (validate and correct as needed):"];
	for (const t of tests.slice(0, 10)) {
		const statusIcon = t.result === "pass" ? "✓" : t.result === "fail" ? "✗" : "?";
		lines.push(`- ${statusIcon} ${t.cmd}`);
		if (t.failures) {
			for (const f of t.failures.slice(0, 3)) {
				lines.push(`  - ${f}`);
			}
		}
	}
	return lines.join("\n");
}

/**
 * Generate an initial v2 structured summary from dropped messages.
 * Used for the first compaction in a session.
 */
export async function generateInitialStructuredSummaryV2(
	droppedMessages: AppMessage[],
	artifactSnapshot: ArtifactIndex,
	model: Model<any>,
	apiKey: string,
	signal?: AbortSignal,
	customInstructions?: string,
): Promise<StructuredSummaryV2> {
	let prompt = INITIAL_SUMMARY_V2_PROMPT;

	// Add test hints if available
	const testHints = formatTestHints(artifactSnapshot.tests);
	if (testHints) {
		prompt += `\n\n${testHints}`;
	}

	if (customInstructions) {
		prompt += `\n\nAdditional focus: ${customInstructions}`;
	}

	// Transform custom messages to LLM-compatible messages
	const transformedMessages = messageTransformer(droppedMessages);

	const summarizationMessages = [
		...transformedMessages,
		{
			role: "user" as const,
			content: [{ type: "text" as const, text: prompt }],
			timestamp: Date.now(),
		},
	];

	const response = await complete(
		model,
		{ messages: summarizationMessages },
		{ maxTokens: SUMMARY_TOKEN_BUDGET, signal, apiKey },
	);

	const textContent = response.content
		.filter((c): c is { type: "text"; text: string } => c.type === "text")
		.map((c) => c.text)
		.join("\n");

	// Parse the LLM output into structured format
	const parsed = parseStructuredSummaryFromMarkdown(`${SUMMARY_V2_MARKER}\n\n${textContent}`);
	const parsedValid = parsed ? isValidStructuredSummaryV2Output(textContent, parsed) : false;

	// If parsing/validation failed, create a minimal summary with the raw output
	const summary = parsedValid && parsed ? parsed : createEmptyStructuredSummary();
	if (!parsedValid) {
		summary.sessionIntent.push(textContent.slice(0, 500));
	}

	// Merge in the deterministic artifact index (excluding tests - those come from LLM)
	summary.artifactIndex = mergeArtifactIndices(summary.artifactIndex, artifactSnapshot);

	return summary;
}

/**
 * Update an existing v2 structured summary with new dropped messages.
 * This is the core of anchored iterative summarization.
 */
export async function updateStructuredSummaryV2(
	previousSummary: StructuredSummaryV2,
	droppedMessages: AppMessage[],
	newArtifactSnapshot: ArtifactIndex,
	model: Model<any>,
	apiKey: string,
	signal?: AbortSignal,
	customInstructions?: string,
): Promise<StructuredSummaryV2> {
	// Serialize previous summary for the LLM
	const previousMarkdown = structuredSummaryToMarkdown(previousSummary);

	let prompt = UPDATE_SUMMARY_V2_PROMPT;

	// Add test hints from newly detected tests
	const testHints = formatTestHints(newArtifactSnapshot.tests);
	if (testHints) {
		prompt += `\n\n${testHints}`;
	}

	if (customInstructions) {
		prompt += `\n\nAdditional focus: ${customInstructions}`;
	}

	// Transform custom messages to LLM-compatible messages
	const transformedMessages = messageTransformer(droppedMessages);

	const summarizationMessages = [
		{
			role: "user" as const,
			content: [{ type: "text" as const, text: `PREVIOUS_SUMMARY:\n\n${previousMarkdown}` }],
			timestamp: Date.now(),
		},
		{
			role: "user" as const,
			content: [{ type: "text" as const, text: "DROPPED_SPAN (new messages to incorporate):" }],
			timestamp: Date.now(),
		},
		...transformedMessages,
		{
			role: "user" as const,
			content: [{ type: "text" as const, text: prompt }],
			timestamp: Date.now(),
		},
	];

	const response = await complete(
		model,
		{ messages: summarizationMessages },
		{ maxTokens: SUMMARY_TOKEN_BUDGET, signal, apiKey },
	);

	const textContent = response.content
		.filter((c): c is { type: "text"; text: string } => c.type === "text")
		.map((c) => c.text)
		.join("\n");

	// Parse the LLM output into structured format
	const parsed = parseStructuredSummaryFromMarkdown(`${SUMMARY_V2_MARKER}\n\n${textContent}`);
	const parsedValid = parsed ? isValidStructuredSummaryV2UpdateOutput(textContent, previousSummary, parsed) : false;

	// If parsing/validation failed, preserve previous summary and add warning
	const summary = parsedValid && parsed ? parsed : cloneStructuredSummary(previousSummary);
	if (!parsedValid) {
		summary.openQuestions.push("(Summary update parsing failed - content may be incomplete)");
	}

	// Merge artifact indices: previous + new (deterministic, not LLM-dependent)
	summary.artifactIndex = mergeArtifactIndices(previousSummary.artifactIndex, newArtifactSnapshot);

	return summary;
}

// ============================================================================
// Summarization
// ============================================================================

const SUMMARIZATION_PROMPT = `You are performing a CONTEXT CHECKPOINT COMPACTION. Create a handoff summary for another LLM that will resume the task.

Include:
- Current progress and key decisions made
- Important context, constraints, or user preferences
- Absolute file paths of any relevant files that were read or modified
- What remains to be done (clear next steps)
- Any critical data, examples, or references needed to continue

Be concise, structured, and focused on helping the next LLM seamlessly continue the work.`;

/**
 * Generate a summary of the conversation using the LLM.
 */
export async function generateSummary(
	currentMessages: AppMessage[],
	model: Model<any>,
	reserveTokens: number,
	apiKey: string,
	signal?: AbortSignal,
	customInstructions?: string,
): Promise<string> {
	const maxTokens = Math.floor(0.8 * reserveTokens);

	const prompt = customInstructions
		? `${SUMMARIZATION_PROMPT}\n\nAdditional focus: ${customInstructions}`
		: SUMMARIZATION_PROMPT;

	// Transform custom messages (like bashExecution) to LLM-compatible messages
	const transformedMessages = messageTransformer(currentMessages);

	const summarizationMessages = [
		...transformedMessages,
		{
			role: "user" as const,
			content: [{ type: "text" as const, text: prompt }],
			timestamp: Date.now(),
		},
	];

	const response = await complete(model, { messages: summarizationMessages }, { maxTokens, signal, apiKey });

	if (response.stopReason === "error") {
		throw new Error(`Summarization failed: ${response.errorMessage || "Unknown error"}`);
	}

	const textContent = response.content
		.filter((c): c is { type: "text"; text: string } => c.type === "text")
		.map((c) => c.text)
		.join("\n");

	return textContent;
}

// ============================================================================
// Compaction Preparation (for hooks)
// ============================================================================

export interface CompactionPreparation {
	cutPoint: CutPointResult;
	/** Messages that will be summarized and discarded */
	messagesToSummarize: AppMessage[];
	/** Messages that will be kept after the summary (recent turns) */
	messagesToKeep: AppMessage[];
	tokensBefore: number;
	boundaryStart: number;
}

export function prepareCompaction(entries: SessionEntry[], settings: CompactionSettings): CompactionPreparation | null {
	if (entries.length > 0 && entries[entries.length - 1].type === "compaction") {
		return null;
	}

	let prevCompactionIndex = -1;
	for (let i = entries.length - 1; i >= 0; i--) {
		if (entries[i].type === "compaction") {
			prevCompactionIndex = i;
			break;
		}
	}
	const boundaryStart = prevCompactionIndex + 1;
	const boundaryEnd = entries.length;

	const lastUsage = getLastAssistantUsage(entries);
	const tokensBefore = lastUsage ? calculateContextTokens(lastUsage) : 0;

	const cutPoint = findCutPoint(entries, boundaryStart, boundaryEnd, settings.keepRecentTokens);

	// Messages to summarize (will be dropped and replaced by the compaction summary).
	// This includes split-turn prefixes (if the cut point is inside a turn).
	const droppedEnd = cutPoint.firstKeptEntryIndex;

	const messagesToSummarize: AppMessage[] = [];
	for (let i = boundaryStart; i < droppedEnd; i++) {
		const entry = entries[i];
		const msg = getMessageFromEntry(entry);
		if (msg) messagesToSummarize.push(msg);
	}

	// Messages to keep (recent turns, kept after summary)
	const messagesToKeep: AppMessage[] = [];
	for (let i = cutPoint.firstKeptEntryIndex; i < boundaryEnd; i++) {
		const entry = entries[i];
		const msg = getMessageFromEntry(entry);
		if (msg) messagesToKeep.push(msg);
	}

	return { cutPoint, messagesToSummarize, messagesToKeep, tokensBefore, boundaryStart };
}

// ============================================================================
// Main compaction function
// ============================================================================

/**
 * Calculate compaction and generate summary.
 * Returns CompactionResult - SessionManager adds uuid/parentUuid when saving.
 *
 * This now uses v2 structured summaries with anchored iterative updates:
 * - First compaction: generates initial structured summary
 * - Subsequent compactions: updates existing summary with only new dropped messages
 *
 * @param entries - All session entries (must have uuid fields for v2)
 * @param model - Model to use for summarization
 * @param settings - Compaction settings
 * @param apiKey - API key for LLM
 * @param signal - Optional abort signal
 * @param customInstructions - Optional custom focus for the summary
 */
export async function compact(
	entries: SessionEntry[],
	model: Model<any>,
	settings: CompactionSettings,
	apiKey: string,
	signal?: AbortSignal,
	customInstructions?: string,
): Promise<CompactionResult> {
	// Don't compact if the last entry is already a compaction
	if (entries.length > 0 && entries[entries.length - 1].type === "compaction") {
		throw new Error("Already compacted");
	}

	// Find previous compaction boundary
	let prevCompactionIndex = -1;
	for (let i = entries.length - 1; i >= 0; i--) {
		if (entries[i].type === "compaction") {
			prevCompactionIndex = i;
			break;
		}
	}
	const boundaryStart = prevCompactionIndex + 1;
	const boundaryEnd = entries.length;

	// Get token count before compaction
	const lastUsage = getLastAssistantUsage(entries);
	const tokensBefore = lastUsage ? calculateContextTokens(lastUsage) : 0;

	// Find cut point (entry index) within the valid range
	const cutResult = findCutPoint(entries, boundaryStart, boundaryEnd, settings.keepRecentTokens);

	// Extract messages for history summary (before the turn that contains the cut point)
	const historyEnd = cutResult.isSplitTurn ? cutResult.turnStartIndex : cutResult.firstKeptEntryIndex;
	const historyMessages: AppMessage[] = [];
	for (let i = boundaryStart; i < historyEnd; i++) {
		const msg = getMessageFromEntry(entries[i]);
		if (msg) historyMessages.push(msg);
	}

	// Extract messages for turn prefix (if splitting a turn)
	const turnPrefixMessages: AppMessage[] = [];
	if (cutResult.isSplitTurn) {
		for (let i = cutResult.turnStartIndex; i < cutResult.firstKeptEntryIndex; i++) {
			const msg = getMessageFromEntry(entries[i]);
			if (msg) turnPrefixMessages.push(msg);
		}
	}

	// Combine all dropped messages for summarization
	// For split turns, include the dropped prefix too so the summary isn't empty
	const droppedSpanMessages = [...historyMessages, ...turnPrefixMessages];

	if (droppedSpanMessages.length === 0) {
		throw new Error("Nothing to compact: no messages to drop");
	}

	// Extract artifact index from all dropped messages
	const droppedArtifacts = extractArtifactIndex(droppedSpanMessages);

	// Get previous summary if there was a compaction
	let previousSummaryV2: StructuredSummaryV2 | null = null;
	if (prevCompactionIndex >= 0) {
		const prevCompaction = entries[prevCompactionIndex] as CompactionEntry;

		if (isV2Summary(prevCompaction.summary)) {
			// Parse existing v2 summary
			previousSummaryV2 = parseStructuredSummaryFromMarkdown(prevCompaction.summary);
		} else {
			// Convert v1 to v2
			previousSummaryV2 = convertV1ToV2Summary(prevCompaction.summary);
		}
	}

	// Generate structured summary
	let structuredSummary: StructuredSummaryV2;

	if (previousSummaryV2) {
		// Incremental update: only summarize dropped span and merge with existing
		structuredSummary = await updateStructuredSummaryV2(
			previousSummaryV2,
			droppedSpanMessages,
			droppedArtifacts,
			model,
			apiKey,
			signal,
			customInstructions,
		);
	} else {
		// First compaction: generate initial summary
		structuredSummary = await generateInitialStructuredSummaryV2(
			droppedSpanMessages,
			droppedArtifacts,
			model,
			apiKey,
			signal,
			customInstructions,
		);
	}

	// Serialize to markdown
	const summaryMarkdown = structuredSummaryToMarkdown(structuredSummary);

	// Get UUID of first kept entry
	const firstKeptEntry = entries[cutResult.firstKeptEntryIndex];
	const firstKeptEntryId = firstKeptEntry.id;
	if (!firstKeptEntryId) {
		throw new Error("First kept entry has no UUID - session may need migration");
	}

	return {
		summary: summaryMarkdown,
		firstKeptEntryId,
		tokensBefore,
		details: structuredSummary,
	};
}
